<!doctype html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DELTA+</title>
    <link rel="stylesheet" href="https://use.typekit.net/tas7aat.css">
    <style>
        :root {
            --video-frame-radius: clamp(18px, 3vw, 38px);
            --video-frame-corner-length: clamp(24px, 8vw, 90px);
            --video-frame-outline-offset: 10px;
            --video-frame-outline-inner-offset: -4px;
            --video-frame-padding: clamp(6px, 0px, 6px);
        }


        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            overflow-x: hidden;
        }

        body {
            margin: 0;
            font-family: "new-science", system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
            background-color: #000;
            background-image: url('assets/web-bgs/D+fondo_para_web_01.webp');
            /* Make the background cover the full viewport and move with the page scroll */
            background-position: top center;
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: scroll;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            width: 100%;
        }

        body.is-loading,
        html.no-scroll,
        body.no-scroll {
            overflow: hidden !important;
            height: 100% !important;
        }

        /* ER logo top-left */
        .er-logo {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 2000;
            pointer-events: none;
            padding: 8px 12px;
        }

        .er-logo img {
            height: clamp(12px, 2.4vw, 28px);
            width: auto;
            display: block;
            filter: brightness(0) invert(1);
            opacity: 0.5;
        }

        #bg-transition-root {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: -1;
        }

        .bg-transition-layer {
            position: absolute;
            inset: 0;
            background-position: top center;
            background-repeat: no-repeat;
            background-size: cover;
            opacity: 0;
            transition: opacity 2s ease-in-out;
            will-change: opacity;
        }

        .bg-transition-layer.is-visible {
            opacity: 1;
        }

        /* Video sections - full viewport height and centered content
              Sections are separate blocks and their inner frames occupy 95vw */
        .video-section {
            width: 100%;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
            overflow-y: visible;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 40px 0;
            box-sizing: border-box;
        }

        .video-section.hero {
            overflow: hidden;
        }

        .video-section video {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Loader overlay appears before the homepage renders */
        #page-loader {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.94), #000 65%);
            z-index: 100000;
            transition: opacity 500ms ease, visibility 500ms ease;
            overflow: hidden;
        }

        #page-loader::after {
            content: '';
            position: absolute;
            inset: 0;
            background: #000;
            border-radius: var(--video-frame-radius);
            opacity: 0;
            transition: opacity 800ms ease;
            pointer-events: none;
            z-index: 2;
        }

        #page-loader.is-blackout::after {
            opacity: 1;
        }

        #page-loader.is-blackout video {
            opacity: 0;
        }

        #page-loader.is-hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        #page-loader video {
            width: clamp(110px, 9vw, 260px);
            height: auto;
            position: relative;
            z-index: 1;
            transition: opacity 400ms ease;
        }

        /* Entry gate shown after loader */
        #entry-gate {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 99990;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            pointer-events: none;
            transition: opacity 900ms ease;
        }

        #entry-gate.is-fading {
            opacity: 0;
            pointer-events: none;
        }

        #entry-gate.is-interactive {
            pointer-events: auto;
        }

        #entry-gate button {
            font-family: "new-science", system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
            font-size: clamp(18px, 3vw, 28px);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #FBFE5E;
            background: transparent;
            border: 2px solid #FBFE5E;
            padding: 14px 48px;
            border-radius: 999px;
            cursor: pointer;
            outline: none;
            transition: opacity 240ms ease, transform 240ms ease;
            opacity: 0;
            pointer-events: none;
        }

        #entry-gate button:hover {
            transform: scale(1.02);
        }

        #entry-gate button:active {
            transform: scale(0.99);
        }

        #entry-gate button.is-hiding {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }

        #entry-gate.is-interactive button {
            opacity: 1;
            pointer-events: auto;
        }

        /* Video wrapper with rounded corners and overflow hidden */
        .video-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: var(--video-frame-radius);
            overflow: hidden;
            z-index: 1;
        }

        /* Floating island - centered on first section with higher z-index */
        .floating-island {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            isolation: isolate;
            /* keep blend modes local so black pixels can lighten instead of showing solid */
            /* allow clicks on the island so it can enable audio */
            pointer-events: auto;
            /* cursor: pointer; */
            overflow: visible;
        }

        .floating-island::before {
            content: '';
            position: absolute;
            inset: -14%;
            background: url('assets/nube.png') center center / contain no-repeat;
            mix-blend-mode: lighten;
            opacity: 0;
            filter: hue-rotate(-8deg) saturate(1.05) brightness(1.06);
            animation: cloudTintCycle 20s ease-in-out infinite alternate, cloudDrift 32s ease-in-out infinite alternate;
            animation-play-state: paused;
            transition: opacity 1100ms ease;
            pointer-events: none;
            z-index: 1;
        }

        .floating-island::after {
            content: '';
            position: absolute;
            inset: -14%;
            background: url('assets/nube.png') center center / contain no-repeat;
            mix-blend-mode: lighten;
            opacity: 0;
            filter: hue-rotate(-8deg) saturate(1.05) brightness(1.04);
            animation: cloudTintCycle 20s ease-in-out infinite alternate, cloudDriftFlip 32s ease-in-out infinite alternate;
            animation-play-state: paused;
            transition: opacity 1200ms ease;
            pointer-events: none;
            z-index: 1;
        }

        .floating-island.cloud1-visible::before {
            opacity: 0.3;
            animation-play-state: running;
        }

        .floating-island.cloud2-visible::after {
            opacity: 0.26;
            animation-play-state: running;
        }

        @media (max-width: 768px) {

            .floating-island::before,
            .floating-island::after {
                background-size: 180%;
            }

            .cards-row {
                grid-template-columns: 1fr;
                /* Stack cards vertically on mobile */
                max-width: 280px;
                /* Limit width for better look */
                margin: 0 auto;
            }
        }

        @keyframes cloudTintCycle {
            0% {
                opacity: 0.2;
                filter: hue-rotate(-12deg) sa turate(0.95) brightness(1.02);
            }

            50% {
                opacity: 0.42;
                filter: hue-rotate(24deg) saturate(1.25) brightness(1.12);
            }

            100% {
                opacity: 0.26;
                filter: hue-rotate(-18deg) saturate(1.05) brightness(1.08);
            }
        }

        @keyframes cloudDrift {
            0% {
                transform: translateX(-12%) scale(1.2);
            }

            100% {
                transform: translateX(12%) scale(1.2);
            }
        }

        @keyframes cloudDriftFlip {
            0% {
                transform: translateX(12%) scale(1.2) scaleY(-1);
            }

            100% {
                transform: translateX(-12%) scale(1.2) scaleY(-1);
            }
        }

        #splat-overlay {
            cursor: pointer;
            pointer-events: auto;
        }

        #splat-container {
            opacity: 0;
            transition: opacity 1200ms ease;
            pointer-events: none;
        }

        #splat-container.is-visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* Birds overlay above the island iframe */
        #birds-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 12;
            opacity: 0;
            transition: opacity 600ms ease;
        }

        #birds-overlay.is-active {
            opacity: 1;
        }

        #birds-overlay video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            /* Keep birds roughly 15% above center on wide viewports */
            transform: translateY(-15%);
        }

        /* When viewport is taller than wide, lift less so birds stay visible */
        @media (max-aspect-ratio: 1/1) {
            #birds-overlay video {
                transform: translateY(-8%);
            }
        }

        #spark-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 13;
        }

        /* Floating island transitions */
        .floating-island,
        .floating-island canvas {
            transition: transform 320ms ease;
            transform-origin: center center;
            will-change: transform;
        }

        .floating-island canvas {
            display: block;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            cursor: pointer;
            position: relative;
            z-index: 2;
        }

        /* Video frame container - flow layout and centered
           (no absolute positioning so sections don't overlap/crop) */
        .video-frame-container {
            position: relative;
            width: 100%;
            max-width: none;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            padding: 8px 0;
        }

        /* Content container for third section */
        .content-container {
            position: relative;
            width: 100%;
            max-width: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
            box-sizing: border-box;
            padding: 8px 0;
        }

        .content-container .video-frame-container {
            position: relative;
            width: 100%;
            box-sizing: border-box;
        }

        /* Frame image as background */
        .video-frame {
            position: relative;
            width: 84vw;
            max-width: 84vw;
            aspect-ratio: 16/9;
            margin: 0 auto;
            padding: 0;
            overflow: visible;
            box-sizing: border-box;
            border-radius: var(--video-frame-radius);
        }

        /* Overlay graphic instead of corner borders */
        .video-frame::after {
            content: '';
            position: absolute;
            inset: 0;
            background: url('assets/marco-videos.webp') center center / 100% 100% no-repeat;
            border-radius: inherit;
            pointer-events: none;
            z-index: 4;
        }



        .video-frame::before {
            display: none;
        }

        .video-frame .frame-corner {
            display: none;
            position: absolute;
            width: var(--video-frame-corner-length);
            height: var(--video-frame-corner-length);
            border: 3px solid #FBFE5E;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 3;
            box-shadow:
                0 0 10px rgba(255, 255, 94, 0.7),
                0 0 22px rgba(255, 255, 94, 0.45);
        }

        .video-frame .frame-corner.top-left {
            top: 0;
            left: 0;
            transform: translate(-5%, -5%);
            border-top-color: #FBFE5E;
            border-left-color: #FBFE5E;
            border-right-color: transparent;
            border-bottom-color: transparent;
            border-top-left-radius: var(--video-frame-radius);
        }

        .video-frame .frame-corner.top-right {
            top: 0;
            right: 0;
            transform: translate(5%, -5%);
            border-top-color: #FBFE5E;
            border-right-color: #FBFE5E;
            border-left-color: transparent;
            border-bottom-color: transparent;
            border-top-right-radius: var(--video-frame-radius);
        }

        .video-frame .frame-corner.bottom-left {
            bottom: 0;
            left: 0;
            transform: translate(-5%, 5%);
            border-bottom-color: #FBFE5E;
            border-left-color: #FBFE5E;
            border-top-color: transparent;
            border-right-color: transparent;
            border-bottom-left-radius: 54px;
        }

        .video-frame .frame-corner.bottom-right {
            bottom: 0;
            right: 0;
            transform: translate(5%, 5%);
            border-bottom-color: #FBFE5E;
            border-right-color: #FBFE5E;
            border-top-color: transparent;
            border-left-color: transparent;
            border-bottom-right-radius: 54px;
        }

        /* Video wrapper with rounded corners and overflow hidden */
        .video-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: var(--video-frame-radius);
            overflow: hidden;
            z-index: 1;
        }

        .video-shell {
            position: absolute;
            inset: 0;
            border-radius: var(--video-frame-radius);
            outline: none;
            outline-offset: 0;
            overflow: hidden;
        }

        /* Clean frame modifier - removes outlines and borders */
        .video-frame.clean-frame::before {
            display: none;
        }

        .video-frame.clean-frame .video-shell {
            outline: none;
        }

        .video-frame.clean-frame .video-shell iframe,
        .video-frame.clean-frame .video-shell video {
            border: none;
        }

        .video-shell iframe,
        .video-shell video {
            position: absolute;
            inset: 0;
            border-radius: var(--video-frame-radius);
            box-sizing: border-box;
            border: none;
        }

        /* YouTube iframe */
        .video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: var(--video-frame-radius);
        }

        /* Local video element */
        .video-wrapper video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: var(--video-frame-radius);
        }

        /* Make the giant map clickable and show pointer */
        .map-link {
            display: block;
            width: 100%;
            text-decoration: none;
            color: inherit;
        }

        .map-link .video-wrapper {
            cursor: pointer;
        }

        /* Cards strip below video frame */
        .cards-section {
            width: 100%;
            margin: 0 auto;
            box-sizing: border-box;
            padding: 12px 10px 18px;
            display: grid;
            gap: 8px;
            justify-items: center;
        }

        .cards-row {
            width: 92vw;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            align-items: stretch;
        }

        .card-item {
            width: 100%;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            position: relative;
            background: transparent;
            margin: 0 auto;
        }

        .card-item img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        /* Hero scroll indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
            z-index: 40;
        }

        .scroll-indicator.is-visible {
            opacity: 1;
            animation: scrollPulse 1.6s ease-in-out infinite;
        }

        .scroll-indicator .arrow {
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 18px solid #FBFE5E;
            filter: drop-shadow(0 0 8px rgba(255, 254, 94, 0.45));
        }

        @keyframes scrollPulse {
            0% {
                transform: translate(-50%, 0);
            }

            50% {
                transform: translate(-50%, 8px);
            }

            100% {
                transform: translate(-50%, 0);
            }
        }

        /* Manifiesto item: same background and font as .news-item,
           positioned top-left in the hero and vertically scrollable */
        .manifiesto-item {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 50;
            width: 300px;
            height: 450px;
            background: none;
            padding: 0;
            color: #DDDC31;
            font-family: "new-science", sans-serif;
            font-size: 17px;
            line-height: 1.6;
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            opacity: 0;
            transition: opacity 1.5s ease;
        }

        .manifiesto-item.is-visible {
            opacity: 1;
        }

        .manifiesto-item.dragging {
            opacity: 0.8;
            cursor: grabbing;
            z-index: 100;
        }

        .manifiesto-item p {
            margin: 0;
        }

        /* Small visible scrollbar for desktop, unobtrusive on mobile */
        .manifiesto-item::-webkit-scrollbar {
            width: 8px;
        }

        .manifiesto-item::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.12);
            border-radius: 6px;
        }

        @media (max-width: 768px) {
            .manifiesto-item {
                display: none;
            }
        }

        /* Logo arriba centrado en el hero */
        .logo-naranja {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 60;
            width: 300px;
            max-width: 60vw;
            pointer-events: none;
        }

        .logo-naranja video {
            display: block;
            width: 100%;
            height: auto;
        }

        /* Jugar button */
        .jugar-button {
            position: absolute;
            bottom: 12%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            padding: 12px 40px;
            font-size: 24px;
            font-weight: bold;
            font-family: "new-science", sans-serif;
            color: #000;
            background: linear-gradient(135deg, #DDDC31 0%, #FFE55C 100%);
            border: 3px solid #fff;
            border-radius: 40px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            pointer-events: auto;
        }

        .jugar-button:hover {
            transform: translateX(-50%) translateY(-5px);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.8);
            background: linear-gradient(135deg, #FFE55C 0%, #DDDC31 100%);
        }

        .jugar-button:active {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.6);
        }

        /* Sound selector (hero section bottom centered) */
        .video-section.hero .sound-selector {
            position: absolute;
            bottom: 5%;
            left: 50%;
            transform: translate(-50%, 0);
            z-index: 21;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 1.5s ease;
            max-width: 1200px;
            width: min(90vw, 1200px);
        }

        /* Keep the selector at its 16:9 size on taller/narrower screens (e.g. phones) */
        @media (max-aspect-ratio: 16/9) {
            .video-section.hero .sound-selector {
                width: 1200px;
                max-width: none;
            }
        }

        .video-section.hero .sound-selector.is-visible {
            opacity: 1;
        }

        .video-section.hero .sound-selector img {
            display: block;
            cursor: pointer;
            width: 100%;
            max-width: 100%;
            height: auto;
        }

        .sound-tooltip {
            position: absolute;
            padding: 6px 10px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            font-size: 12px;
            letter-spacing: 0.04em;
            border: 1px solid rgba(255, 229, 92, 0.7);
            pointer-events: none;
            opacity: 0;
            transition: opacity 120ms ease, transform 120ms ease;
            white-space: nowrap;
            z-index: 23;
        }

        .sound-tooltip.is-visible {
            opacity: 1;
            transform: translate(-50%, -14px);
        }

        /* Hotspots are invisible (image contains UI). Keep focus-visible outline for accessibility. */
        .video-section.hero .sound-hotspot {
            background: transparent !important;
            border: none !important;
            opacity: 0 !important;
            box-shadow: none !important;
        }

        .video-section.hero .sound-hotspot:focus-visible {
            opacity: 1 !important;
            outline: 2px solid #FFE55C;
            outline-offset: 4px;
            background: rgba(0, 0, 0, 0.18);
        }

        /* Debug panel removed in production */
        /* Footer styles */
        .site-footer {
            width: 100%;
            padding: 28px 18px;
            box-sizing: border-box;
            text-align: center;
            color: #FFF;
            font-family: "new-science", 'New Science', system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
            font-size: 14px;
            letter-spacing: 0.08em;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.55));
            backdrop-filter: blur(4px);
        }

        .site-footer__inner {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.06);
        }

        /* PWA action buttons */
        .pwa-actions {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            margin-left: 12px;
        }

        .pwa-button {
            padding: 8px 14px;
            font-size: 13px;
            font-weight: 700;
            color: #FBFE5E;
            background: rgba(0, 102, 204, 0);
            border: 2px solid #FBFE5E;
            border-radius: 24px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        .pwa-button:hover {
            background: rgba(0, 102, 204, 0.5);
            border-color: #FFE55C;
        }

        .pwa-button[hidden] {
            display: none;
        }

        /* Credits overlay */
        .credits-open {
            overflow: hidden;
        }

        .credits-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.78);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 120000;
            padding: 20px;
        }

        .credits-overlay.is-visible {
            display: flex;
        }

        .credits-panel {
            width: min(880px, 94vw);
            max-height: 86vh;
            background: rgba(12, 12, 12, 0.94);
            border: 1px solid rgba(255, 255, 255, 0.16);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.55);
            color: #f7f7f7;
            padding: 22px 24px;
            font-family: "new-science", 'New Science', system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
            display: grid;
            gap: 16px;
            overflow: hidden;
        }

        .credits-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .credits-header h2 {
            font-size: 20px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin: 0;
        }

        .credits-body {
            overflow-y: auto;
            max-height: 60vh;
            padding-right: 6px;
            font-size: 14px;
            line-height: 1.6;
        }

        .credits-body strong {
            color: #FFE55C;
        }

        /* Video Overlay */
        .video-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 130000;
        }

        .video-overlay.is-visible {
            display: flex;
        }

        .video-overlay .video-frame {
            position: relative;
            width: 100%;
            max-width: 177.78vh;
            /* 16/9 aspect ratio constraint based on height */
            aspect-ratio: 16/9;
            max-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-overlay .video-frame video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            outline: none;
        }

        .overlay-text {
            position: absolute;
            left: 62.5%;
            top: 17.1%;
            width: 18%;
            max-height: 27%;
            overflow-y: auto;
            font-family: "new-science-mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
            color: #FFC96A;
            font-size: 14px;
            line-height: 1.5;
            padding: 10px;
            pointer-events: auto;
            scrollbar-width: thin;
            scrollbar-color: #FFC96A rgba(11, 18, 28, 0.45);
            display: none;
            z-index: 130001;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .overlay-text.is-visible {
            display: block;
        }

        .overlay-text::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }

        .overlay-text::-webkit-scrollbar-track {
            background: rgba(11, 18, 28, 0.38);
            border-radius: 4px;
        }

        .overlay-text::-webkit-scrollbar-thumb {
            background: #FFC96A;
            border-radius: 4px;
        }

        .overlay-text strong {
            color: #FFE55C;
            font-weight: 700;
        }

        .overlay-text p {
            margin-bottom: 1em;
        }

        @keyframes glitch-flicker {

            0%,
            100% {
                opacity: 0.6;
            }

            50% {
                opacity: 0.2;
            }
        }

        /* Toast / progress UI */
        .pwa-toast {
            position: fixed;
            left: 50%;
            bottom: 24px;
            transform: translateX(-50%);
            min-width: 280px;
            max-width: 90%;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 12px 14px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 20000;
        }

        .pwa-toast[hidden] {
            display: none;
        }

        .pwa-progress {
            flex: 1 1 auto;
            height: 10px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            overflow: hidden;
        }

        .pwa-progress>.bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #DDDC31, #FFE55C);
            transition: width 260ms linear;
        }

        .pwa-toast .label {
            font-size: 13px;
            white-space: nowrap;
        }

        .pwa-toast .filename-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .pwa-toast-bottom {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            margin-top: 4px;
        }

        .pwa-toast .size-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            white-space: nowrap;
        }

        .pwa-cancel-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: rgba(255, 80, 80, 0.2);
            border: 1px solid rgba(255, 80, 80, 0.4);
            border-radius: 6px;
            color: #ff6b6b;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .pwa-cancel-btn:hover {
            background: rgba(255, 80, 80, 0.3);
            border-color: rgba(255, 80, 80, 0.6);
        }

        .pwa-cancel-btn[hidden] {
            display: none;
        }

        .site-footer__inner strong {
            display: inline-block;
            font-weight: 700;
            color: #FFE55C;
            margin-right: 8px;
        }

        /* Floating transition texts between sections */
        .floating-text {
            width: 100%;
            padding: 60px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;
            z-index: 5;
        }

        .floating-text p,
        .floating-text div {
            font-family: "new-science", 'New Science', system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
            color: #FBFE5E;
            font-size: clamp(18px, 3vw, 28px);
            line-height: 1.6;
            max-width: 900px;
            margin: 0 0 1.2em 0;
            letter-spacing: 0.02em;
        }

        .floating-text p:last-child,
        .floating-text div:last-child {
            margin-bottom: 0;
        }

        /* Floating text typewriter styles */
        .floating-text[data-typewriter] p {
            min-height: 1.6em;
            text-align: left;
        }

        .floating-text[data-typewriter] div {
            min-height: 1.6em;
            text-align: left;
        }

        .floating-text[data-typewriter] p:empty,
        .floating-text[data-typewriter] div:empty {
            visibility: hidden;
        }

        /* Waveform style */
        .waveform-container {
            position: absolute;
            top: 20px;
            /* Keep it visible on screen even if parent overflows using max and calc */
            right: max(60px, calc((100% - 100vw) / 2 + 30px));
            bottom: auto;
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 30px;
            padding: 0;
            z-index: 1000;
            pointer-events: none;
            transition: opacity 0.5s ease;
            opacity: 0;
        }

        .waveform-container.is-visible {
            opacity: 1;
        }

        .waveform-bar {
            width: 3px;
            background-color: #fc8f21;
            height: 2px;
            border-radius: 2px;
            transition: height 0.05s ease;
        }
    </style>
</head>

<body class="is-loading">
    <!-- Top-left ER horizontal logo -->
    <div class="er-logo">
        <img src="assets/LOGO_ER_horizontal.png" alt="ER" loading="eager" />
    </div>
    <div id="page-loader" aria-live="polite" aria-label="Cargando Delta+">
        <video autoplay muted playsinline preload="auto">
            <source src="assets/D+_loader04.webm" type="video/webm">
        </video>
    </div>
    <div id="entry-gate" aria-hidden="true">
        <button id="entry-button" type="button">ENTRAR</button>
    </div>
    <div id="bg-transition-root" aria-hidden="true"></div>
    <div id="bg-dark-overlay"
        style="position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: -1; pointer-events: none;"
        aria-hidden="true"></div>
    <!-- First video section with floating island (background video removed to show body image) -->
    <section class="video-section hero">
        <!-- Floating island centered on top: draw video into a canvas (preserves alpha and allows extra compositing) -->
        <div class="floating-island">

            <div id="splat-container"
                style="display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0;z-index: 3;">
                <iframe id="splat-iframe" src="isla%20splat/isla_splat.html"
                    style="width: 100%; height: 100%; border: none; background: transparent;"
                    allowtransparency="true"></iframe>
                <div id="splat-overlay" style="position: absolute; inset: 0; z-index: 10;"></div>
                <div id="birds-overlay" aria-hidden="true">
                    <video id="birds-video" muted loop playsinline preload="auto">
                        <source src="assets/birds.webm" type="video/webm">
                    </video>
                </div>
                <canvas id="spark-canvas" aria-hidden="true"></canvas>
            </div>
            <!--  <div id="island-loader"
                style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 140px; padding: 10px 10px 8px; background: rgba(0,0,0,0.55); border-radius: 8px; overflow: hidden; pointer-events: none; text-align: center; color: #fff; font-size: 13px; letter-spacing: 0.04em;">
                <div style="margin-bottom: 6px;">Cargando isla...</div>
                <div
                    style="width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden;">
                    <div id="island-loader-bar"
                        style="width: 0%; height: 100%; background: #DDDC31; transition: width 0.1s linear;"></div>
                </div>
            </div>
            <div id="splat-loader"
                style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 14px 20px; background: rgba(0,0,0,0.55); border-radius: 8px; pointer-events: none; text-align: center; color: #fff; font-size: 13px; letter-spacing: 0.04em; z-index: 0;">
                Cargando isla...
            </div> -->
            <div class="sound-selector" aria-hidden="false" role="group" aria-label="Selector de sonido">
                <img src="assets/selectores/selector-sonido-off.png" alt="Selector de sonido" id="sound-toggle">
                <div class="waveform-container" id="waveform">
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                    <div class="waveform-bar"></div>
                </div>
            </div>

            <div class="scroll-indicator" id="scroll-indicator" aria-hidden="true">
                <div class="arrow"></div>
            </div>
        </div>

        <div class="logo-naranja" aria-hidden="false">
            <video autoplay loop muted playsinline aria-hidden="true">
                <source src="assets/logo_naranja_alpha.webm" type="video/webm">
            </video>
        </div>

        <div class="manifiesto-item" role="region" aria-label="Manifiesto Delta Grande">
            <div class="grid-frame-wrapper" style="position: relative; width: 100%; height: 100%;">
                <canvas id="manifiesto-canvas"
                    style="position: absolute; top: -20px; left: -20px; pointer-events: none;"></canvas>
                <div class="grid-frame-content"
                    style="position: relative; z-index: 1; width: 100%; height: 100%; padding: 70px 1px 59px 79px; overflow-y: auto;">
                    <p>Delta Grande es un ecosistema digital donde podés explorar el Delta del Paraná a través de
                        juegos,
                        recorridos interactivos, microdocumentales, paisajes 3D, voces y sonidos del territorio.</p>
                </div>
            </div>
        </div>

        <!-- 'Jugar' button removed from landing (kept in-game menu link removed) -->
    </section>

    <!-- Floating text between section 1 and 2 -->
    <div class="floating-text">

        <p>El Delta entrerriano, un largo abrazo de ríos que envuelven nuestra llanura, nuestros humedales, nuestros
            hombres y mujeres y niños. Nuestro equilibrio anfibio: la tierra camina en el agua, el agua camina en la
            tierra.</p>
    </div>

    <!-- Second video section with framed YouTube video (background video removed to show body image) -->
    <section class="video-section">
        <!-- Video frame container -->
        <div class="video-frame-container">
            <div class="video-frame">
                <div class="video-wrapper">
                    <div class="video-shell">
                        <iframe src="https://www.youtube.com/embed/ANyR_fuIF-g?rel=0&modestbranding=1&playsinline=1"
                            title="Video"
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                            allowfullscreen>
                        </iframe>
                    </div>
                </div>
                <span class="frame-corner top-left"></span>
                <span class="frame-corner top-right"></span>
                <span class="frame-corner bottom-left"></span>
                <span class="frame-corner bottom-right"></span>
            </div>
        </div>
    </section>

    <!-- Floating text between section 2 and 3 -->
    <div class="floating-text">
        <div>
            Esta historia empezó hace diez mil años.
            Y es tanto el tiempo, que el colibrí vuela en cámara lenta.
            ¿Cuántas cosas ocurren a la vez? ¿Cuánto podemos ver en lo que miramos?

        </div>
    </div>

    <!-- Third video section with framed local video (background video removed to show body image) -->
    <section class="video-section">
        <!-- Juegos banner -->
        <div style="text-align: center; margin-bottom: 40px;">
            <img src="assets/ui/juegos banner.png" alt="Juegos" style="max-width: 300px; width: 100%; height: auto;">
        </div>
        <!-- Content container with video and news -->
        <div class="content-container">
            <!-- Video frame container -->
            <div class="video-frame-container">
                <a href="game/index.html#menu" class="map-link" aria-label="Ir al juego">
                    <div class="video-frame">
                        <div class="video-wrapper">
                            <div class="video-shell">
                                <video autoplay loop muted playsinline>
                                    <source src="assets/mapa_gigante.webm" type="video/webm">
                                </video>
                            </div>
                        </div>
                        <span class="frame-corner top-left"></span>
                        <span class="frame-corner top-right"></span>
                        <span class="frame-corner bottom-left"></span>
                        <span class="frame-corner bottom-right"></span>
                    </div>
                </a>
            </div>

            <!-- Cards strip -->
            <div class="cards-section">
                <div class="cards-row" id="cards-row-top"></div>
                <div class="cards-row" id="cards-row-bottom"></div>
            </div>
        </div>
    </section>

    <script>
        (function () {
            const cardImages = [
                'assets/cards_webp/aguara.webp',
                'assets/cards_webp/armado.webp',
                'assets/cards_webp/banderita.webp',
                'assets/cards_webp/camalote.webp',
                'assets/cards_webp/carancho.webp',
                'assets/cards_webp/cardenal.webp',
                'assets/cards_webp/carpintero.webp',
                'assets/cards_webp/ceibo.webp',
                'assets/cards_webp/chaja.webp',
                'assets/cards_webp/clavel.webp',
                'assets/cards_webp/culebra.webp',
                'assets/cards_webp/dorado.webp',
                'assets/cards_webp/efedra.webp',
                'assets/cards_webp/espinillo.webp',
                'assets/cards_webp/guazuncho.webp',
                'assets/cards_webp/malvavisco.webp',
                'assets/cards_webp/martin.webp',
                'assets/cards_webp/mburucuya.webp',
                'assets/cards_webp/murcielago.webp',
                'assets/cards_webp/ombu.webp',
                'assets/cards_webp/pacu.webp',
                'assets/cards_webp/paloma.webp',
                'assets/cards_webp/palometa.webp',
                'assets/cards_webp/rana.webp',
                'assets/cards_webp/raya.webp',
                'assets/cards_webp/salvia.webp',
                'assets/cards_webp/suelda.webp',
                'assets/cards_webp/surubi.webp',
                'assets/cards_webp/tembetari.webp',
                'assets/cards_webp/tortuga.webp',
                'assets/cards_webp/vieja.webp',
                'assets/cards_webp/viraro.webp',
                'assets/cards_webp/yacare.webp',
                'assets/cards_webp/yaguarundi.webp',
                'assets/cards_webp/yarara.webp',
                'assets/cards_webp/yatei.webp',
                'assets/cards_webp/yesquero.webp'
            ];

            function shuffle(arr) {
                const a = arr.slice();
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            }

            let speciesData = [];
            const audioOpen = new Audio('game-assets/recorrido/sonido/metadata_popup.mp3');
            const audioClose = new Audio('game-assets/recorrido/sonido/metadata_cierre.mp3');
            audioOpen.volume = 0.4;
            audioClose.volume = 0.5;

            // Glitch animation variables
            let typeWriterTimeout = null;
            let typeWriterInterval = null;
            const glitchChars = "!@#$%^&*()_+-=[]{}|;':\",./<>?~`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

            const getRandomGlitchChar = () => glitchChars[Math.floor(Math.random() * glitchChars.length)];

            const getPlainTextLength = (html) => {
                const temp = document.createElement('div');
                temp.innerHTML = html;
                return temp.textContent.length;
            };

            const getPartialHTML = (html, charCount) => {
                const temp = document.createElement('div');
                temp.innerHTML = html;
                let count = 0;

                const walk = (node, maxChars) => {
                    if (count >= maxChars) return '';
                    if (node.nodeType === Node.TEXT_NODE) {
                        const remaining = maxChars - count;
                        const text = node.textContent.substring(0, remaining);
                        count += text.length;
                        return text;
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        const tagName = node.tagName.toLowerCase();
                        let result = `<${tagName}>`;
                        for (let child of node.childNodes) {
                            if (count >= maxChars) break;
                            result += walk(child, maxChars);
                        }
                        result += `</${tagName}>`;
                        return result;
                    }
                    return '';
                };

                let result = '';
                for (let child of temp.childNodes) {
                    if (count >= charCount) break;
                    result += walk(child, charCount);
                }
                return result;
            };

            const isVideoPixelTransparent = (videoElement, event) => {
                if (!videoElement || videoElement.readyState < 2) return false;

                const rect = videoElement.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = videoElement.videoWidth;
                canvas.height = videoElement.videoHeight;

                context.drawImage(videoElement, 0, 0);

                const scaleX = videoElement.videoWidth / rect.width;
                const scaleY = videoElement.videoHeight / rect.height;
                const pixelX = Math.floor(x * scaleX);
                const pixelY = Math.floor(y * scaleY);

                const pixelData = context.getImageData(pixelX, pixelY, 1, 1).data;
                const alpha = pixelData[3];

                return alpha < 128;
            };

            // Fetch species data
            fetch('game/data/especies.json')
                .then(response => response.json())
                .then(data => {
                    speciesData = data.species;
                })
                .catch(err => console.error('Error loading species data:', err));

            function openVideoOverlay(src, speciesId) {
                const overlay = document.getElementById('video-overlay');
                const video = document.getElementById('overlay-video');
                const textOverlay = document.getElementById('overlay-text');

                if (!overlay || !video) return;

                // Clear any existing animations
                if (typeWriterTimeout) clearTimeout(typeWriterTimeout);
                if (typeWriterInterval) clearInterval(typeWriterInterval);

                video.src = src;
                video.play().catch(e => console.error("Video play failed:", e));

                overlay.classList.add('is-visible');
                overlay.setAttribute('aria-hidden', 'false');

                // Play sound
                audioOpen.currentTime = 0;
                audioOpen.play().catch(e => console.log('Audio play failed', e));

                // Populate text if data exists
                if (textOverlay && speciesId) {
                    const info = speciesData.find(s => s.id === speciesId);
                    if (info) {
                        // Set video speed
                        video.playbackRate = info.dataVideoSpeed || 0.5;

                        if (info.text) {
                            textOverlay.innerHTML = ''; // Start empty
                            textOverlay.classList.add('is-visible');

                            // Start animation after 3 seconds
                            typeWriterTimeout = setTimeout(() => {
                                const fullText = info.text;
                                const totalChars = getPlainTextLength(fullText);
                                let currentIndex = 0;

                                typeWriterInterval = setInterval(() => {
                                    if (currentIndex <= totalChars) {
                                        let displayText = getPartialHTML(fullText, currentIndex);
                                        const glitchCount = Math.min(3, totalChars - currentIndex);
                                        for (let i = 0; i < glitchCount; i++) {
                                            displayText += `<span style="opacity: 0.6; animation: glitch-flicker 0.1s infinite;">${getRandomGlitchChar()}</span>`;
                                        }
                                        textOverlay.innerHTML = displayText;
                                        currentIndex++;
                                    } else {
                                        textOverlay.innerHTML = fullText;
                                        clearInterval(typeWriterInterval);
                                    }
                                }, 5);
                            }, 3000);
                        } else {
                            textOverlay.classList.remove('is-visible');
                            textOverlay.innerHTML = '';
                        }
                    } else {
                        // Default speed if no info found
                        video.playbackRate = 0.5;
                        textOverlay.classList.remove('is-visible');
                        textOverlay.innerHTML = '';
                    }
                } else if (textOverlay) {
                    video.playbackRate = 0.5;
                    textOverlay.classList.remove('is-visible');
                    textOverlay.innerHTML = '';
                }

                // Close on click outside
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        closeVideoOverlay();
                    }
                };

                // Close on transparent pixel click
                video.onclick = (e) => {
                    if (isVideoPixelTransparent(video, e)) {
                        closeVideoOverlay();
                    }
                };
            }

            function closeVideoOverlay() {
                const overlay = document.getElementById('video-overlay');
                const video = document.getElementById('overlay-video');
                const textOverlay = document.getElementById('overlay-text');

                if (!overlay || !video) return;

                // Clear animations
                if (typeWriterTimeout) clearTimeout(typeWriterTimeout);
                if (typeWriterInterval) clearInterval(typeWriterInterval);

                video.pause();
                video.src = '';
                video.onclick = null; // Remove listener
                overlay.classList.remove('is-visible');
                overlay.setAttribute('aria-hidden', 'true');

                if (textOverlay) {
                    textOverlay.classList.remove('is-visible');
                    textOverlay.innerHTML = '';
                }

                // Play close sound
                audioClose.currentTime = 0;
                audioClose.play().catch(e => console.log('Audio play failed', e));
            }

            function renderCards() {
                const rows = [
                    document.getElementById('cards-row-top'),
                    document.getElementById('cards-row-bottom')
                ].filter(Boolean);

                if (!rows.length || !cardImages.length) return;

                const isMobile = window.innerWidth <= 768;
                const count = isMobile ? 3 : 8;
                const picks = shuffle(cardImages).slice(0, count);

                // Clear existing
                rows.forEach(row => row.innerHTML = '');

                if (isMobile) {
                    // Mobile: all 3 in the first row
                    const row = rows[0];
                    picks.forEach(src => {
                        const card = createCardElement(src, true);
                        row.appendChild(card);
                    });
                } else {
                    // Desktop: 4 per row
                    rows.forEach((row, rowIndex) => {
                        const start = rowIndex * 4;
                        const end = start + 4;
                        picks.slice(start, end).forEach((src) => {
                            const card = createCardElement(src, false);
                            row.appendChild(card);
                        });
                    });
                }
            }

            function createCardElement(src, disableClick) {
                const card = document.createElement('div');
                card.className = 'card-item';
                card.style.cursor = disableClick ? 'default' : 'pointer';

                const img = document.createElement('img');
                img.src = src;
                img.alt = 'Carta del Delta';
                img.loading = 'lazy';

                card.appendChild(img);

                if (!disableClick) {
                    card.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const filename = src.split('/').pop();
                        const species = filename.split('.')[0];
                        const videoPath = `game-assets/recorrido/criaturas/${species}/${species}_data.webm`;

                        // Check if video exists before opening
                        fetch(videoPath, { method: 'HEAD' })
                            .then(res => {
                                const type = res.headers.get('content-type');
                                if (res.ok && type && type.startsWith('video/')) {
                                    openVideoOverlay(videoPath, species);
                                } else {
                                    console.warn('Video not found or invalid type for species:', species, type);
                                }
                            })
                            .catch(e => {
                                console.warn('Error checking video existence:', e);
                            });
                    });
                }

                return card;
            }

            document.addEventListener('DOMContentLoaded', renderCards);

            // Re-render on resize if crossing breakpoint
            let wasMobile = window.innerWidth <= 768;
            window.addEventListener('resize', () => {
                const isMobile = window.innerWidth <= 768;
                if (isMobile !== wasMobile) {
                    wasMobile = isMobile;
                    renderCards();
                }
            });
        })();
    </script>

    <script>
        // Show the down arrow after a brief delay to hint scrolling
        (function () {
            const indicator = document.getElementById('scroll-indicator');
            const SHOW_DELAY_MS = 3000;
            if (!indicator) return;

            function reveal() { indicator.classList.add('is-visible'); }

            function startTimer() {
                setTimeout(reveal, SHOW_DELAY_MS);
            }

            window.addEventListener('dg:entry-ui', startTimer, { once: true });
        })();
    </script>



    <!-- Floating text between section 3 and footer -->
    <div class="floating-text">
        <p>Delta Grande existe gracias al trabajo conjunto de científicas y científicos, docentes, artistas,
            programadores, diseñadores, productores, pobladoras y pobladores del Delta que, con orgullo y compromiso,
            hacen posible esta obra colectiva. Las muchas voces a las que atravesaron los ríos.</p>
    </div>

    <!-- Site footer -->
    <footer class="site-footer" aria-label="Pie de página">
        <div class="site-footer__inner">
            <strong>© Delta Grande 2025</strong> Todos los derechos reservados
            <span class="pwa-actions" aria-hidden="false">
                <button id="pwaInstallBtn" class="pwa-button" hidden aria-label="Instalar aplicación">Instalar</button>
                <button id="pwaSaveBtn" class="pwa-button" aria-label="Guardar para uso offline">Guardar
                    offline</button>
                <button id="credits-btn" class="pwa-button" aria-label="Ver créditos">Créditos</button>
            </span>
        </div>
    </footer>

    <!-- Credits overlay -->
    <div id="credits-overlay" class="credits-overlay" aria-hidden="true" role="dialog" aria-modal="true">
        <div class="credits-panel">
            <div class="credits-header">
                <h2>Créditos</h2>
                <button id="credits-close" class="pwa-button" type="button" aria-label="Cerrar créditos">Cerrar</button>
            </div>
            <div class="credits-body">
                <p><strong>Delta Grande</strong> — Proyecto interdisciplinario de arte, ciencia y tecnología.</p>
                <p><strong>Dirección creativa:</strong> Equipo Delta Grande.</p>
                <p><strong>Desarrollo interactivo:</strong> Equipo Delta Grande.</p>
                <p><strong>Arte y animación:</strong> Equipo Delta Grande.</p>
                <p><strong>Investigación y relatos:</strong> Equipo Delta Grande.</p>
                <p><strong>Música y sonido:</strong> Equipo Delta Grande.</p>
                <p style="margin-top:12px;">Gracias a todas las comunidades, especialistas y colaboradores que hicieron
                    posible este recorrido.</p>
            </div>
        </div>
    </div>

    <!-- Video overlay -->
    <div id="video-overlay" class="video-overlay" aria-hidden="true">
        <div
            style="position: relative; width: 100%; max-width: 177.78vh; aspect-ratio: 16/9; max-height: 100vh; display: flex; align-items: center; justify-content: center;">
            <video id="overlay-video" loop playsinline
                style="width: 100%; height: 100%; object-fit: contain; outline: none;"></video>
            <div id="overlay-text" class="overlay-text"></div>
        </div>
    </div>

    <script>
        const WELCOME_THEME = {
            fontKitHref: 'https://use.typekit.net/vmy8ypx.css',
            fonts: {
                family: `"new-science-mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace`
            },
            colors: {
                text: '#FBFE5E',
                textShadow: 'rgba(0, 0, 0, 0.45)'
            }
        };

        window.showWelcomeSequence = async function (onComplete) {
            // Load font
            if (!document.getElementById('efedra-transition-font')) {
                const link = document.createElement('link');
                link.id = 'efedra-transition-font';
                link.rel = 'stylesheet';
                link.href = WELCOME_THEME.fontKitHref;
                document.head.appendChild(link);
            }

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'welcome-overlay';
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                z-index: 100001;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                pointer-events: auto;
                opacity: 0;
                transition: opacity 0.5s ease;
                background: #000;
            `;
            document.body.appendChild(overlay);

            // Background video
            const bgVideo = document.createElement('video');
            bgVideo.src = 'assets/web-bgs/web-bg01.webm';
            bgVideo.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                object-fit: cover;
                opacity: 0.6;
            `;
            bgVideo.muted = true;
            bgVideo.playsInline = true;
            bgVideo.loop = true;
            bgVideo.autoplay = true;

            bgVideo.onerror = () => {
                console.warn('Video failed to load, falling back to image');
                bgVideo.style.display = 'none';
                overlay.style.backgroundImage = "url('assets/web-bgs/D+fondo_para_web_01.webp')";
                overlay.style.backgroundSize = 'cover';
                overlay.style.backgroundPosition = 'center';
            };

            overlay.appendChild(bgVideo);

            try {
                await bgVideo.play();
            } catch (e) {
                console.warn('Video play failed', e);
            }

            // Scale logic - Simplified for better mobile readability
            // We won't scale the text container, but we will use responsive units
            const updateScale = () => {
                // No-op for text container to allow responsive CSS to work
                // We might want to scale other elements if needed, but for now let's rely on CSS
            };
            window.addEventListener('resize', updateScale);

            // Text Container
            const textContainer = document.createElement('div');
            textContainer.style.cssText = `
                position: absolute;
                inset: 0;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 0 20px;
                z-index: 10002;
            `;
            overlay.appendChild(textContainer);

            // Skip Button
            const skipButton = document.createElement('button');
            skipButton.textContent = 'SALTEAR';
            skipButton.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                padding: 12px 24px;
                background: rgba(255, 201, 106, 0.15);
                border: 2px solid ${WELCOME_THEME.colors.text};
                color: ${WELCOME_THEME.colors.text};
                font-family: ${WELCOME_THEME.fonts.family};
                font-size: 14px;
                font-weight: bold;
                letter-spacing: 0.08em;
                cursor: pointer;
                z-index: 10004;
                pointer-events: auto;
                text-shadow: 0 0 14px ${WELCOME_THEME.colors.textShadow};
                transition: all 0.3s ease;
            `;

            skipButton.addEventListener('mouseenter', () => {
                skipButton.style.background = `rgba(255, 201, 106, 0.35)`;
                skipButton.style.transform = `scale(1.05)`;
            });
            skipButton.addEventListener('mouseleave', () => {
                skipButton.style.background = `rgba(255, 201, 106, 0.15)`;
                skipButton.style.transform = `scale(1)`;
            });

            let skipRequested = false;
            skipButton.addEventListener('click', (e) => {
                e.stopPropagation();
                skipRequested = true;
            });
            overlay.appendChild(skipButton);

            // Click Indicator
            const clickIndicator = document.createElement('div');
            clickIndicator.className = 'welcome-click-indicator';
            clickIndicator.style.cssText = `
                position: absolute;
                bottom: 10%;
                left: 50%;
                transform: translateX(-50%);
                color: ${WELCOME_THEME.colors.text};
                font-family: ${WELCOME_THEME.fonts.family};
                font-size: 0.95em;
                text-align: center;
                text-shadow: 0 0 14px ${WELCOME_THEME.colors.textShadow};
                z-index: 10003;
                opacity: 0;
                transition: opacity 0.5s ease;
                pointer-events: none;
                width: 100%;
            `;
            clickIndicator.innerHTML = `
                <span style="display:inline-block; letter-spacing:0.04em;">Click para continuar</span>
            `;
            overlay.appendChild(clickIndicator);

            // Add styles for animations
            if (!document.getElementById('welcome-anim-style')) {
                const style = document.createElement('style');
                style.id = 'welcome-anim-style';
                style.textContent = `
                    @keyframes clickFloat {
                        0%,100% { transform: translate(-50%, 0); }
                        50% { transform: translate(-50%, -6px); }
                    }
                    @keyframes rippleGrow {
                        0% { transform: translate(-50%, 0) scale(0.7); opacity: 0.35; }
                        70% { opacity: 0.08; }
                        100% { transform: translate(-50%, 0) scale(1.25); opacity: 0; }
                    }
                    .welcome-click-indicator { animation: clickFloat 2.8s ease-in-out infinite; }
                    .welcome-click-indicator .efedra-ripple.r1 { animation: rippleGrow 2.8s ease-in-out infinite; animation-delay: .0s; }
                    .welcome-click-indicator .efedra-ripple.r2 { animation: rippleGrow 2.8s ease-in-out infinite; animation-delay: 1.4s; }

                    /* Entrada/salida más suave */
                    @keyframes fadeWaveIn {
                        from { opacity: 0; transform: translateY(24px); filter: blur(4px); }
                        to { opacity: 0.98; transform: translateY(0); filter: blur(0); }
                    }
                    @keyframes fadeWaveOut {
                        from { opacity: 1; transform: translateY(0); }
                        to { opacity: 0; transform: translateY(-26px); }
                    }

                    /* Ondas por carácter */
                    @keyframes charWave {
                        0%, 100% { transform: translateY(0); }
                        50% { transform: translateY(var(--waveAmp, 6px)); }
                    }
                `;
                document.head.appendChild(style);
            }

            // Initial scale update
            updateScale();

            // Show overlay
            requestAnimationFrame(() => {
                overlay.style.opacity = '1';
            });

            const lines = [
                "Bienvenidx a Delta Grande, un ecosistema digital donde podés explorar el Delta del Paraná a través de juegos, recorridos interactivos, microdocumentales, paisajes 3D, voces y sonidos del territorio.",
                "Acá vas a descubrir la vida del Delta desde una experiencia que combina arte, ciencia y tecnología, y que te permitirá recorrerlo sin dejar huella: jugar, aprender y sumergirte en uno de los ecosistemas más singulares de Sudamérica."
            ];

            const currentLineContainer = document.createElement('div');
            currentLineContainer.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 1200px;
                text-align: center;
            `;
            textContainer.appendChild(currentLineContainer);

            for (let i = 0; i < lines.length; i++) {
                if (skipRequested) break;
                const line = lines[i];

                currentLineContainer.innerHTML = '';
                currentLineContainer.style.opacity = '1';

                const lineElement = document.createElement('div');
                lineElement.style.cssText = `
                    color: ${WELCOME_THEME.colors.text};
                    font-family: ${WELCOME_THEME.fonts.family};
                    font-size: clamp(24px, 2.5vw, 30px);
                    line-height: 1.5;
                    text-shadow: 0 0 14px ${WELCOME_THEME.colors.textShadow};
                    animation: fadeWaveIn 0.6s ease-out forwards;
                `;
                currentLineContainer.appendChild(lineElement);

                // Build spans per word for wave animation
                const spans = [];
                const parts = line.split(/(\n)/);

                for (const part of parts) {
                    if (part === '\n') {
                        lineElement.appendChild(document.createElement('br'));
                    } else {
                        const words = part.split(' ');
                        for (let w = 0; w < words.length; w++) {
                            const wordText = words[w];
                            if (!wordText) continue;

                            const s = document.createElement('span');
                            s.textContent = wordText;
                            s.style.display = 'inline-block';
                            s.style.opacity = '0';
                            s.style.transform = 'translateY(10px)';
                            s.style.filter = 'blur(3px)';
                            s.style.transition = 'opacity 220ms ease-out, transform 360ms ease-out, filter 480ms ease-out';
                            s.style.willChange = 'transform, opacity, filter';

                            // Continuous wave animation once revealed
                            s.style.setProperty('--waveAmp', '5px');
                            s.style.animation = `charWave 2800ms ease-in-out ${spans.length * 150}ms infinite`;

                            lineElement.appendChild(s);
                            spans.push(s);

                            // Add space after word
                            if (w < words.length - 1) {
                                lineElement.appendChild(document.createTextNode(' '));
                            }
                        }
                    }
                }

                let isTyping = true;
                let skipTyping = false;
                let advanceToNext = false;

                // Show click indicator
                clickIndicator.style.opacity = '1';

                const clickHandler = () => {
                    if (isTyping) {
                        skipTyping = true;
                    } else {
                        advanceToNext = true;
                    }
                };
                overlay.addEventListener('click', clickHandler);

                // Typewriter effect
                for (let j = 0; j < spans.length; j++) {
                    if (skipRequested) {
                        skipTyping = true;
                    }

                    if (skipTyping) {
                        for (let k = 0; k < spans.length; k++) {
                            const el = spans[k];
                            el.style.opacity = '1';
                            el.style.transform = 'translateY(0)';
                            el.style.filter = 'blur(0)';
                        }
                        break;
                    }

                    const el = spans[j];
                    el.style.opacity = '1';
                    el.style.transform = 'translateY(0)';
                    el.style.filter = 'blur(0)';

                    let delay = 100;
                    const wordText = el.textContent;
                    const lastChar = wordText[wordText.length - 1];

                    if (lastChar === ',' || lastChar === ';') delay = 300;
                    else if (lastChar === '.' || lastChar === ':') delay = 500;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }

                isTyping = false;

                if (skipRequested) {
                    advanceToNext = true;
                }

                if (!skipRequested) {
                    await new Promise(resolve => setTimeout(resolve, 400));
                }

                if (!advanceToNext && !skipRequested) {
                    await new Promise(resolve => {
                        const checkAdvance = setInterval(() => {
                            if (advanceToNext || skipRequested) {
                                clearInterval(checkAdvance);
                                resolve();
                            }
                        }, 50);
                    });
                }

                overlay.removeEventListener('click', clickHandler);

                if (i < lines.length - 1) {
                    clickIndicator.style.opacity = '0';
                    currentLineContainer.style.transition = 'opacity 0.3s ease';
                    currentLineContainer.style.opacity = '0';
                    await new Promise(resolve => setTimeout(resolve, 300));
                } else {
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
            }

            // Cleanup
            if (onComplete) onComplete();

            // Small delay to ensure loader is hidden behind the overlay before fading out overlay
            await new Promise(r => setTimeout(r, 100));

            overlay.style.transition = 'opacity 2s ease'; // Slower fade out
            overlay.style.opacity = '0';

            // Trigger fade-in of selector and manifesto after 3 seconds
            setTimeout(() => {
                const selector = document.querySelector('.sound-selector');
                const manifesto = document.querySelector('.manifiesto-item');
                if (selector) selector.classList.add('is-visible');
                if (manifesto) manifesto.classList.add('is-visible');
            }, 3000);

            setTimeout(() => {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
                window.removeEventListener('resize', updateScale);
            }, 2000); // Wait for the 2s transition
        };
    </script>

    <script>
        // Display the loader for 4 seconds, fade to black, hold 2 seconds, then reveal the page
        (function () {
            // Force scroll to top on every load and prevent browser scroll restoration
            if ('scrollRestoration' in history) {
                history.scrollRestoration = 'manual';
            }
            window.scrollTo(0, 0);

            const loader = document.getElementById('page-loader');
            const loaderVideo = loader ? loader.querySelector('video') : null;
            const body = document.body;
            const entryGate = document.getElementById('entry-gate');
            const entryButton = document.getElementById('entry-button');
            const floatingIsland = document.querySelector('.floating-island');
            const birdsOverlay = document.getElementById('birds-overlay');
            const birdsVideo = document.getElementById('birds-video');
            const ua = navigator.userAgent || '';
            const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|FxiOS|Edg/i.test(ua);
            const disableBirds = isSafari; // Safari cannot show WebM alpha
            const splatContainer = document.getElementById('splat-container');
            const sparkCanvas = document.getElementById('spark-canvas');
            const sparkCtx = sparkCanvas ? sparkCanvas.getContext('2d') : null;
            const MIN_DISPLAY_MS = 4000;
            const BLACKOUT_FADE_MS = 800;
            const BLACKOUT_HOLD_MS = 2000;
            const FALLBACK_REVEAL_MS = MIN_DISPLAY_MS + BLACKOUT_FADE_MS + BLACKOUT_HOLD_MS + 2000;
            let loaderHidden = false;
            let revealStarted = false;
            let entryStarted = false;
            let uiRevealed = false;

            if (disableBirds && birdsOverlay) {
                birdsOverlay.style.display = 'none';
            }

            const sparkState = {
                running: false,
                raf: 0,
                lastTs: 0,
                squares: [],
                dots: [],
                resizeHandler: null,
                angleY: 0,
                targetAngleY: 0
            };

            // Allow other scripts (drag handler) to push yaw rotations
            window.dgSetSparkYaw = (delta) => {
                sparkState.targetAngleY += delta;
            };

            const resizeSparkCanvas = () => {
                if (!sparkCanvas || !sparkCtx) return;
                const ratio = window.devicePixelRatio || 1;
                const width = splatContainer?.clientWidth || sparkCanvas.clientWidth || sparkCanvas.parentElement?.clientWidth || 0;
                const height = splatContainer?.clientHeight || sparkCanvas.clientHeight || sparkCanvas.parentElement?.clientHeight || 0;
                sparkCanvas.width = width * ratio;
                sparkCanvas.height = height * ratio;
                sparkCtx.setTransform(ratio, 0, 0, ratio, 0, 0);
            };

            const startSparks = () => {
                if (!sparkCanvas || !sparkCtx || sparkState.running) return;
                resizeSparkCanvas();
                sparkState.running = true;
                sparkState.lastTs = 0;

                const spawnSquare = (width, height) => {
                    // Spawn in an ellipse, with depth for pseudo-3D
                    const rx = width * 0.2184; // +20% radius
                    const ry = Math.max(height * 0.155, width * 0.09);  // Scale with width on wide screens
                    const rz = Math.max(width, height) * 0.2; // depth range
                    const ang = Math.random() * Math.PI * 2;
                    const rad = Math.sqrt(Math.random());
                    const x = Math.cos(ang) * rx * rad;
                    const y = (Math.random() - 0.688) * ry; // lift higher (~+44% from original)
                    const z = Math.random() * rz; // 0 front, rz back
                    const speed = 18 + Math.random() * 16;
                    // Random unit direction for free flight
                    const dirTheta = Math.random() * Math.PI * 2;
                    const dirPhi = Math.acos(2 * Math.random() - 1);
                    const dx = Math.sin(dirPhi) * Math.cos(dirTheta);
                    const dy = Math.cos(dirPhi);
                    const dz = Math.sin(dirPhi) * Math.sin(dirTheta);
                    // Scale size based on width, uncapped for wide screens
                    const viewportScale = width / 1600;
                    const size = (6 + Math.random() * 10) * Math.max(0.7, viewportScale);
                    const colors = ['rgba(251, 254, 94, 1)', 'rgba(255, 255, 255, 1)', 'rgba(76, 91, 255, 1)'];
                    const life = 1.1 + Math.random() * 0.9;
                    sparkState.squares.push({
                        x,
                        y,
                        z,
                        vx: dx * speed,
                        vy: dy * speed,
                        vz: dz * speed,
                        size,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        life,
                        ttl: life
                    });
                };

                const spawnDot = (width, height) => {
                    const rx = width * 0.2184; // +20% radius
                    const ry = Math.max(height * 0.155, width * 0.09);  // Scale with width on wide screens
                    const rz = Math.max(width, height) * 0.2;
                    const ang = Math.random() * Math.PI * 2;
                    const rad = Math.sqrt(Math.random());
                    const x = Math.cos(ang) * rx * rad;
                    const y = (Math.random() - 0.288) * ry; // lift higher (~+44% from original)
                    const z = Math.random() * rz;
                    const viewportScale = width / 1600;
                    const size = (2 + Math.random() * 3) * 0.2 * Math.max(1, viewportScale);
                    const speed = 12 + Math.random() * 10;
                    const dirTheta = Math.random() * Math.PI * 2;
                    const dirPhi = Math.acos(2 * Math.random() - 1);
                    const dx = Math.sin(dirPhi) * Math.cos(dirTheta);
                    const dy = Math.cos(dirPhi);
                    const dz = Math.sin(dirPhi) * Math.sin(dirTheta);
                    sparkState.dots.push({ x, y, z, size, ttl: 2, life: 2, vx: dx * speed, vy: dy * speed, vz: dz * speed });
                };

                const loop = (ts) => {
                    if (!sparkState.running) return;
                    const ratio = window.devicePixelRatio || 1;
                    const width = sparkCanvas.clientWidth || sparkCanvas.width / ratio;
                    const height = sparkCanvas.clientHeight || sparkCanvas.height / ratio;
                    if (width === 0 || height === 0) {
                        sparkState.raf = requestAnimationFrame(loop);
                        return;
                    }

                    const dt = sparkState.lastTs ? (ts - sparkState.lastTs) / 1000 : 0;
                    sparkState.lastTs = ts;

                    if (dt && sparkState.squares.length < 46) {
                        const spawns = Math.floor(dt * 7);
                        for (let i = 0; i < spawns; i++) spawnSquare(width, height);
                        if (Math.random() < dt * 4) spawnSquare(width, height);
                    }

                    if (dt && sparkState.dots.length < 40) {
                        if (Math.random() < dt * 8) spawnDot(width, height);
                    }

                    const ctx = sparkCtx;
                    ctx.clearRect(0, 0, width, height);

                    // Ease toward target angle so rotation feels smooth
                    sparkState.angleY += (sparkState.targetAngleY - sparkState.angleY) * 0.12;
                    const cosY = Math.cos(sparkState.angleY);
                    const sinY = Math.sin(sparkState.angleY);
                    // Scale fov with viewport size to maintain perspective scale (zooming in as viewport grows)
                    const fov = Math.max(width, height) * 0.5;
                    const cx = width * 0.5;
                    const cy = height * 0.53;
                    const zOffset = Math.max(width, height) * 0.4; // push everything forward to avoid z<=0

                    const next = [];
                    for (const s of sparkState.squares) {
                        s.ttl -= dt;
                        if (s.ttl <= 0) continue;
                        s.x += s.vx * dt;
                        s.y += s.vy * dt;
                        s.z += s.vz * dt;
                        // Mild damping to keep motion contained
                        s.vx *= 0.995;
                        s.vy *= 0.995;
                        s.vz *= 0.995;

                        // Rotate around Y
                        const rx = s.x * cosY - s.z * sinY;
                        const rz = s.x * sinY + s.z * cosY + zOffset;
                        if (rz <= 12) continue; // avoid divide by small z

                        const persp = fov / rz;
                        const sx = cx + rx * persp;
                        const sy = cy + s.y * persp;
                        const size = s.size * persp;

                        if (size < 0.3 || sx < -100 || sx > width + 100 || sy < -100 || sy > height + 100) {
                            continue;
                        }

                        ctx.globalAlpha = 0.5;
                        ctx.lineWidth = 0.55;
                        ctx.strokeStyle = s.color;
                        ctx.strokeRect(sx - size / 2, sy - size / 2, size, size);
                        next.push(s);
                    }
                    ctx.globalAlpha = 1;
                    sparkState.squares = next;

                    const nextDots = [];
                    for (const d of sparkState.dots) {
                        d.ttl -= dt;
                        if (d.ttl <= 0) continue;
                        d.x += d.vx * dt;
                        d.y += d.vy * dt;
                        d.z += d.vz * dt;
                        d.vx *= 0.995;
                        d.vy *= 0.995;
                        d.vz *= 0.995;

                        const rx = d.x * cosY - d.z * sinY;
                        const rz = d.x * sinY + d.z * cosY + zOffset;
                        if (rz <= 12) continue;
                        const persp = fov / rz;
                        const sx = cx + rx * persp;
                        const sy = cy + d.y * persp;
                        const size = d.size * persp;
                        if (size < 0.1) continue;

                        ctx.fillStyle = 'rgba(251, 254, 94, 1)';
                        ctx.beginPath();
                        ctx.arc(sx, sy, size, 0, Math.PI * 2);
                        ctx.fill();
                        nextDots.push(d);
                    }
                    sparkState.dots = nextDots;
                    sparkState.raf = requestAnimationFrame(loop);
                };

                sparkState.resizeHandler = resizeSparkCanvas;
                window.addEventListener('resize', sparkState.resizeHandler);
                sparkState.raf = requestAnimationFrame(loop);
            };

            function shouldSkipLoader() {
                const DEBUG_KEYS = ['debug', 'dgDebug', 'skipLoader'];
                const truthyValues = new Set(['1', 'true', 'yes', 'on', 'skip', 'loader']);
                const sources = [
                    new URLSearchParams(window.location.search),
                    new URLSearchParams(window.location.hash ? window.location.hash.substring(1) : '')
                ];
                const hasDebugParam = sources.some((params) => {
                    return DEBUG_KEYS.some((key) => {
                        if (!params.has(key)) return false;
                        const value = params.get(key);
                        if (!value) return true;
                        return truthyValues.has(value.toLowerCase());
                    });
                });
                if (hasDebugParam) return true;
                try {
                    const stored = localStorage.getItem('dgSkipLoader');
                    if (!stored) return false;
                    return truthyValues.has(stored.toLowerCase());
                } catch (err) {
                    return false;
                }
            }

            const skipLoader = shouldSkipLoader();

            function hideLoader() {
                if (!loader || loaderHidden) return;
                loaderHidden = true;
                loader.classList.add('is-hidden');
                body && body.classList.remove('is-loading');
            }

            function revealUIElements() {
                if (uiRevealed) return;
                uiRevealed = true;
                const selector = document.querySelector('.sound-selector');
                const manifesto = document.querySelector('.manifiesto-item');
                if (selector) selector.classList.add('is-visible');
                if (manifesto) manifesto.classList.add('is-visible');
                window.dispatchEvent(new CustomEvent('dg:entry-ui'));
            }

            function showEntryGate() {
                if (!entryGate) {
                    revealUIElements();
                    return;
                }
                // Ensure page starts at top and prevent scroll
                window.scrollTo(0, 0);
                document.documentElement.classList.add('no-scroll');
                body && body.classList.add('no-scroll');

                entryGate.setAttribute('aria-hidden', 'false');
                entryGate.classList.add('is-interactive');
            }

            function runEntryTimeline() {
                if (entryStarted) return;
                entryStarted = true;

                // Allow scroll again
                document.documentElement.classList.remove('no-scroll');
                body && body.classList.remove('no-scroll');
                if ('scrollRestoration' in history) {
                    history.scrollRestoration = 'auto';
                }

                // Arrancar ambiente apenas el usuario hace clic en "Entrar"
                if (typeof window.playAmbientFromEntry === 'function') {
                    window.playAmbientFromEntry();
                }

                if (entryButton) {
                    entryButton.disabled = true;
                    entryButton.classList.add('is-hiding');
                }

                setTimeout(() => {
                    if (entryGate) entryGate.classList.add('is-fading');
                }, 140);

                setTimeout(() => {
                    if (floatingIsland) floatingIsland.classList.add('cloud1-visible');
                }, 600);

                setTimeout(() => {
                    if (floatingIsland) floatingIsland.classList.add('cloud2-visible');
                }, 1200);

                setTimeout(() => {
                    if (splatContainer) splatContainer.classList.add('is-visible');
                }, 1800);

                if (splatContainer) {
                    let birdsLoopPatched = false;
                    const startBirdsVideo = () => {
                        if (disableBirds) return;
                        if (!birdsVideo) return;
                        birdsVideo.pause();
                        birdsVideo.currentTime = 0;
                        if (!birdsLoopPatched) {
                            const TRIM = 0.5; // trim last 500ms for seamless loop
                            const handleLoopTrim = () => {
                                const d = birdsVideo.duration;
                                if (!Number.isFinite(d) || d <= TRIM) return;
                                if (birdsVideo.currentTime >= d - TRIM) {
                                    birdsVideo.currentTime = 0;
                                    birdsVideo.play().catch(() => { });
                                }
                            };
                            birdsVideo.addEventListener('timeupdate', handleLoopTrim);
                            birdsVideo.addEventListener('ended', handleLoopTrim);
                            birdsLoopPatched = true;
                        }
                        const play = () => {
                            birdsOverlay?.classList.add('is-active');
                            birdsVideo.play().catch(() => { });
                        };
                        const delayPlay = () => setTimeout(play, 5000);
                        if (birdsVideo.readyState >= 2) {
                            delayPlay();
                        } else {
                            birdsVideo.addEventListener('canplay', delayPlay, { once: true });
                        }
                    };

                    const onReady = () => {
                        startBirdsVideo();
                        startSparks();
                    };

                    const onTransitionEnd = (e) => {
                        if (e.target === splatContainer && e.propertyName === 'opacity') {
                            splatContainer.removeEventListener('transitionend', onTransitionEnd);
                            onReady();
                        }
                    };

                    if (getComputedStyle(splatContainer).opacity === '1') {
                        // already visible (e.g., loader skipped)
                        onReady();
                    } else {
                        splatContainer.addEventListener('transitionend', onTransitionEnd);
                    }
                }

                setTimeout(revealUIElements, 2400);

                setTimeout(() => {
                    if (entryGate && entryGate.parentElement) {
                        entryGate.setAttribute('aria-hidden', 'true');
                        entryGate.remove();
                    }
                }, 1700);
            }

            if (entryButton) {
                entryButton.addEventListener('click', runEntryTimeline);
            }

            function startReveal() {
                if (!loader || revealStarted) return;
                revealStarted = true;
                // Skip welcome intro: hide loader immediately
                hideLoader();
                showEntryGate();
            }

            if (skipLoader) {
                hideLoader();
                showEntryGate();
                return; // Debug flag short-circuits the rest of the loader choreography
            }

            if (loaderVideo) {
                loaderVideo.addEventListener('loadedmetadata', () => {
                    if (!loaderVideo.duration) return;
                    const desiredSeconds = MIN_DISPLAY_MS / 1000;
                    const adjustedRate = loaderVideo.duration / desiredSeconds;
                    if (adjustedRate > 0) {
                        loaderVideo.playbackRate = adjustedRate;
                    }
                });
            }

            const loadPromise = new Promise((resolve) => {
                if (document.readyState === 'complete') resolve();
                else window.addEventListener('load', resolve, { once: true });
            });
            const minDisplayPromise = new Promise((resolve) => setTimeout(resolve, MIN_DISPLAY_MS));

            Promise.all([loadPromise, minDisplayPromise]).then(() => {
                requestAnimationFrame(startReveal);
            });

            // Safety timeout in case load event never fires
            setTimeout(startReveal, FALLBACK_REVEAL_MS);
        })();
    </script>

    <script>
        // Background image cycle: fade between hero textures after the page loads (ping-pong order)
        (function () {
            const root = document.getElementById('bg-transition-root');
            const BG_IMAGES = [
                '/assets/web-bgs/D+fondo_para_web_01.webp',
                '/assets/web-bgs/D+fondo_para_web_02.webp',
                '/assets/web-bgs/D+fondo_para_web_03.webp'
            ];
            const DISPLAY_MS = 2000;
            const FADE_MS = 2000;

            if (!root || BG_IMAGES.length < 2) return;

            const layers = [document.createElement('div'), document.createElement('div')];
            let activeLayer = 0;
            let currentIndex = 0;
            let direction = 1;

            layers.forEach((layer) => {
                layer.className = 'bg-transition-layer';
                layer.style.transitionDuration = FADE_MS + 'ms';
                root.appendChild(layer);
            });

            // Preload to avoid flashing when swapping images
            BG_IMAGES.forEach((src) => {
                const img = new Image();
                img.decoding = 'async';
                img.src = src;
            });

            function nextIndex() {
                if (currentIndex === BG_IMAGES.length - 1) direction = -1;
                else if (currentIndex === 0) direction = 1;
                return currentIndex + direction;
            }

            function crossfade(toIdx) {
                const nextLayer = layers[activeLayer ^ 1];
                nextLayer.style.backgroundImage = `url('${BG_IMAGES[toIdx]}')`;
                void nextLayer.offsetWidth; // force reflow so the transition always triggers
                nextLayer.classList.add('is-visible');
                layers[activeLayer].classList.remove('is-visible');
                activeLayer ^= 1;
                currentIndex = toIdx;
            }

            function startCycle() {
                layers[activeLayer].style.backgroundImage = `url('${BG_IMAGES[currentIndex]}')`;
                layers[activeLayer].classList.add('is-visible');

                window.setInterval(() => {
                    const target = nextIndex();
                    crossfade(target);
                }, DISPLAY_MS);
            }

            window.addEventListener('load', startCycle, { once: true });
        })();
    </script>

    <script>
        // Basic PWA install + offline helpers
        (function () {
            let deferredPrompt = null;
            const installBtn = document.getElementById('pwaInstallBtn');
            const saveBtn = document.getElementById('pwaSaveBtn');

            // Listen for the beforeinstallprompt event
            window.addEventListener('beforeinstallprompt', (e) => {
                // Prevent the mini-infobar from appearing on mobile
                e.preventDefault();
                deferredPrompt = e;
                // Show the install button
                if (installBtn) installBtn.hidden = false;
            });

            // Register service worker (if available)
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/service-worker.js').then((reg) => {
                    console.log('ServiceWorker registrado:', reg);
                }).catch((err) => {
                    console.warn('ServiceWorker registro fallido:', err);
                });
            }

            // Install button action
            if (installBtn) {
                installBtn.addEventListener('click', async () => {
                    if (!deferredPrompt) return;
                    deferredPrompt.prompt();
                    const choice = await deferredPrompt.userChoice;
                    if (choice && choice.outcome) {
                        console.log('Install choice:', choice.outcome);
                    }
                    // Hide the install button after attempt
                    deferredPrompt = null;
                    installBtn.hidden = true;
                });
            }

            // Save offline action: send a message to the service worker to cache resources
            if (saveBtn) {
                saveBtn.addEventListener('click', async () => {
                    if (!('serviceWorker' in navigator)) {
                        alert('Service Worker no soportado en este navegador.');
                        return;
                    }

                    try {
                        const reg = await navigator.serviceWorker.ready;
                        if (reg && reg.active) {
                            // Show toast UI and kick off caching
                            showPwaToast('Guardando recursos...', 0);
                            reg.active.postMessage({ type: 'CACHE_OFFLINE' });
                            // The service worker will post progress messages back
                        } else {
                            alert('Service Worker aún no está activo. Intenta de nuevo en unos segundos.');
                        }
                    } catch (err) {
                        console.warn('Error al pedir cache offline:', err);
                        alert('No se pudo iniciar el guardado offline.');
                    }
                });
            }

            // When the app is installed, hide install button
            window.addEventListener('appinstalled', () => {
                if (installBtn) installBtn.hidden = true;
                console.log('App instalada');
            });
        })();
    </script>

    <script>
        // Sound selector hotspots: positions are given relative to the image's natural size.
        (function () {
            const coords = {
                dialog: { x: 798, y: 71 },
                music: { x: 872, y: 40 },
                ambient: { x: 948, y: 71 }
            };
            const RADIUS = 25; // px radius as requested

            // Re-grab the global audio element here (module scope const is not visible in this IIFE)
            const audioEl = document.getElementById('web-music');

            const selectorImg = document.querySelector('.sound-selector img#sound-toggle');
            if (!selectorImg) return;

            // Create container for hotspots (absolute positioned over the image)
            const container = document.createElement('div');
            container.className = 'sound-hotspots-container';
            container.setAttribute('aria-hidden', 'false');
            container.style.position = 'absolute';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '100%';
            container.style.pointerEvents = 'none';
            container.style.zIndex = '22';

            // Ensure the parent (.sound-selector) is positioned relatively
            const selParent = selectorImg.parentElement;

            const tooltip = document.createElement('div');
            tooltip.className = 'sound-tooltip';
            tooltip.setAttribute('role', 'tooltip');
            tooltip.hidden = true;
            if (selParent) selParent.appendChild(tooltip);

            let tooltipTarget = null;
            let hideTooltipTimer = null;

            const tooltipLabels = {
                dialog: 'Relatos',
                music: 'Música',
                ambient: 'Ambiente'
            };

            function positionTooltip(target) {
                if (!tooltip || !selParent || tooltip.hidden) return;
                const rect = target.getBoundingClientRect();
                const parentRect = selParent.getBoundingClientRect();
                const centerX = rect.left - parentRect.left + rect.width / 2;
                const top = rect.top - parentRect.top;
                tooltip.style.left = centerX + 'px';
                tooltip.style.top = (top - 6) + 'px';
            }

            function showTooltip(name, target) {
                if (!tooltip) return;
                if (hideTooltipTimer) {
                    clearTimeout(hideTooltipTimer);
                    hideTooltipTimer = null;
                }
                tooltip.textContent = tooltipLabels[name] || name;
                tooltipTarget = target;
                tooltip.hidden = false;
                positionTooltip(target);
                requestAnimationFrame(() => tooltip.classList.add('is-visible'));
            }

            function hideTooltip() {
                if (!tooltip) return;
                tooltip.classList.remove('is-visible');
                tooltipTarget = null;
                hideTooltipTimer = setTimeout(() => { tooltip.hidden = true; }, 160);
            }

            // Helper to create a hotspot element
            function makeHotspot(name) {
                const el = document.createElement('button');
                el.type = 'button';
                el.className = 'sound-hotspot';
                el.dataset.channel = name;
                el.setAttribute('aria-pressed', 'false');
                el.setAttribute('aria-label', `Alternar ${name}`);
                el.style.position = 'absolute';
                el.style.width = (RADIUS * 2) + 'px';
                el.style.height = (RADIUS * 2) + 'px';
                el.style.borderRadius = '50%';
                el.style.boxSizing = 'border-box';
                el.style.pointerEvents = 'auto';
                el.style.transition = 'transform 180ms ease, background 180ms ease, opacity 180ms ease';
                el.style.display = 'flex';
                el.style.alignItems = 'center';
                el.style.justifyContent = 'center';
                el.style.cursor = 'pointer';
                return el;
            }

            const hotspots = {
                dialog: makeHotspot('dialog'),
                music: makeHotspot('music'),
                ambient: makeHotspot('ambient')
            };

            Object.keys(hotspots).forEach((name) => {
                const el = hotspots[name];
                const show = () => showTooltip(name, el);
                const hide = () => hideTooltip();
                el.addEventListener('mouseenter', show);
                el.addEventListener('focus', show);
                el.addEventListener('mouseleave', hide);
                el.addEventListener('blur', hide);
                el.addEventListener('pointermove', () => {
                    if (tooltipTarget === el && !tooltip.hidden) {
                        positionTooltip(el);
                    }
                });
            });

            // Add to container
            Object.values(hotspots).forEach(h => container.appendChild(h));
            if (selParent) selParent.appendChild(container);

            // Debug panel removed in production build
            const debugContent = null;

            // Positioning function: scale coords from natural image size to displayed size
            function positionHotspots() {
                const naturalW = selectorImg.naturalWidth || selectorImg.width;
                const naturalH = selectorImg.naturalHeight || selectorImg.height;
                const rect = selectorImg.getBoundingClientRect();
                const scaleX = rect.width / naturalW;
                const scaleY = rect.height / naturalH;

                const positions = {};
                Object.keys(coords).forEach((k) => {
                    const c = coords[k];
                    const hx = Math.round(c.x * scaleX - RADIUS);
                    const hy = Math.round(c.y * scaleY - RADIUS);
                    const el = hotspots[k];
                    el.style.left = hx + 'px';
                    el.style.top = hy + 'px';
                    positions[k] = { left: hx, top: hy, rawX: c.x, rawY: c.y };
                });

                if (tooltipTarget && !tooltip.hidden) {
                    positionTooltip(tooltipTarget);
                }

            }

            // Toggle state storage (start all OFF)
            const state = { dialog: false, music: false, ambient: false };

            function updateHotspotUI(name) {
                const el = hotspots[name];
                if (!el) return;
                const on = !!state[name];
                el.dataset.on = on ? '1' : '0';
                el.setAttribute('aria-pressed', on ? 'true' : 'false');
                el.style.background = on ? 'rgba(255,229,92,0)' : 'rgba(0,0,0,0)';
                el.style.transform = on ? 'scale(1.07)' : 'scale(1)';
            }

            // map channel -> image filename
            const channelImage = {
                dialog: 'assets/selectores/selector-sonido-dialogo.png',
                music: 'assets/selectores/selector-sonido-musica.png',
                ambient: 'assets/selectores/selector-sonido-ambiente.png',
                off: 'assets/selectores/selector-sonido-off.png'
            };

            // helper to update selector image based on current state
            function refreshSelectorImage(lastToggled) {
                // If none enabled, show off image
                const enabled = Object.keys(state).filter(k => state[k]);
                if (enabled.length === 0) {
                    selectorImg.src = channelImage.off;
                    return;
                }
                // Prefer the last toggled channel if it's enabled, otherwise pick the first enabled
                if (lastToggled && state[lastToggled]) {
                    selectorImg.src = channelImage[lastToggled] || channelImage.off;
                    return;
                }
                selectorImg.src = channelImage[enabled[0]] || channelImage.off;
            }

            const relatosFiles = [
                'guia-monte-paloma.mp3',
                'gustavo-andino.mp3',
                'nino-2-pesca.mp3',
                'nino-3.mp3',
                'nino-pesca.mp3',
                'norma-isabel-alarcon.mp3',
                'pamela.mp3',
                'ruben-angel-alarcon.mp3'
            ];

            // Wire click handlers
            // Wire click handlers
            Object.keys(hotspots).forEach((k) => {
                const el = hotspots[k];
                el.addEventListener('click', async (ev) => {
                    ev.preventDefault();
                    ev.stopPropagation();

                    // Resolve layers (ensure we have them even if module hasn't run)
                    const layers = window.audioLayers || {
                        ambient: document.getElementById('audio-ambient'),
                        music: document.getElementById('audio-music'),
                        dialog: document.getElementById('audio-dialog')
                    };

                    const wasActive = state[k];

                    // 1. If clicking the currently active selector -> Toggle OFF (Stop All)
                    if (wasActive) {
                        // Reset State
                        Object.keys(state).forEach(s => { state[s] = false; updateHotspotUI(s); });
                        refreshSelectorImage();

                        // Stop All Layers
                        Object.values(layers).forEach(layer => {
                            if (layer) {
                                layer.pause();
                                layer.currentTime = 0;
                            }
                        });
                        return;
                    }

                    // 2. Switching TO a mode

                    // Update UI State: Only clicked one is ON
                    Object.keys(state).forEach(s => { state[s] = (s === k); updateHotspotUI(s); });
                    refreshSelectorImage(k);

                    // Ensure Audio Context is resumed
                    if (typeof window.enableGlobalAudio === 'function') {
                        await window.enableGlobalAudio(true);
                    }

                    // Helper functions
                    const play = async (layerName, vol, src, loop, forceReload = false) => {
                        const l = layers[layerName];
                        if (!l) return;
                        l.volume = vol;
                        l.loop = loop;

                        const alreadyCorrectSrc = l.src && src && l.src.includes(src);
                        if (!alreadyCorrectSrc || forceReload) {
                            l.src = src;
                            l.load();
                        }
                        try { await l.play(); } catch (e) { console.warn('Play error', e); }
                    };

                    const stop = (layerName) => {
                        const l = layers[layerName];
                        if (l) {
                            l.pause();
                            l.currentTime = 0;
                        }
                    };

                    const SRC_MUSIC = 'assets/web_musica.ogg';
                    const SRC_AMBIENT = 'assets/delta-web-ambiente.mp3';

                    // 3. Logic Branches based on selection
                    if (k === 'dialog') {
                        // RELATOS MODE
                        // 1. Play Random Story (100%)
                        const randomFile = relatosFiles[Math.floor(Math.random() * relatosFiles.length)];
                        await play('dialog', 1.0, `assets/relatos/${randomFile}`, false, true);

                        // 2. Ambient BG (50%)
                        await play('ambient', 0.5, SRC_AMBIENT, true, false);

                        // 3. Music BG (50%) - only if it was already playing or part of the vibe?
                        // "lo mismo con la musica" -> imply treating it like ambient. 
                        // We check if it is active or simple assume if it was playing we keep it.
                        if (layers.music && !layers.music.paused) {
                            await play('music', 0.5, SRC_MUSIC, true, false);
                        } else {
                            stop('music');
                        }

                    } else if (k === 'music') {
                        // MUSIC MODE
                        // 1. Music (100%)
                        await play('music', 1.0, SRC_MUSIC, true, false);

                        // 2. Ambient BG (50%)
                        await play('ambient', 0.5, SRC_AMBIENT, true, false);

                        // 3. Stop Dialog
                        stop('dialog');

                    } else if (k === 'ambient') {
                        // AMBIENT MODE
                        // 1. Ambient (100%)
                        await play('ambient', 1.0, SRC_AMBIENT, true, false);

                        // 2. Stop others
                        stop('music');
                        stop('dialog');
                    }
                });
            });

            // Init after image loaded
            if (selectorImg.complete) positionHotspots();
            selectorImg.addEventListener('load', positionHotspots);
            window.addEventListener('resize', positionHotspots);

            // initialize UI
            Object.keys(hotspots).forEach(k => updateHotspotUI(k));
            // Ensure selector image and debug reflect initial OFF state
            try { refreshSelectorImage(); } catch (e) { /* ignore */ }
            // Debugging removed: no initial debug state

            // Allow entry button to start ambient immediately after user gesture
            window.playAmbientFromEntry = async function playAmbientFromEntry() {
                const layers = window.audioLayers || {
                    ambient: document.getElementById('audio-ambient'),
                    music: document.getElementById('audio-music'),
                    dialog: document.getElementById('audio-dialog')
                };
                const audio = layers.ambient;
                if (!audio) return;

                // Reset UI state to only ambient on
                Object.keys(state).forEach(s => { state[s] = false; updateHotspotUI(s); });
                state.ambient = true;
                updateHotspotUI('ambient');
                refreshSelectorImage('ambient');

                // Ensure audio is unlocked
                if (typeof window.enableGlobalAudio === 'function') {
                    await window.enableGlobalAudio(true);
                }

                audio.src = 'assets/delta-web-ambiente.mp3';
                audio.loop = true;
                try {
                    await audio.play();
                } catch (err) {
                    console.warn('No se pudo iniciar ambiente en la entrada:', err);
                }
            };
        })();
    </script>

    <!-- PWA progress toast -->
    <div id="pwaToast" class="pwa-toast" hidden role="status" aria-live="polite">
        <div class="label">Guardando para uso offline...</div>
        <div id="pwaToastFilename" class="filename-label"></div>
        <div class="pwa-progress" aria-hidden="true">
            <div class="bar"></div>
        </div>
        <div class="pwa-toast-bottom">
            <div id="pwaToastPct" class="label">0%</div>
            <div id="pwaToastSize" class="size-label"></div>
        </div>
        <button id="pwaCancelBtn" class="pwa-cancel-btn" hidden>Cancelar</button>
    </div>

    <!-- Global audio layers -->
    <audio id="audio-ambient" loop preload="auto" crossorigin="anonymous"></audio>
    <audio id="audio-music" loop preload="auto" crossorigin="anonymous"></audio>
    <audio id="audio-dialog" preload="auto" crossorigin="anonymous"></audio>





    <script type="module">
        // Expose globally for the other script
        window.audioLayers = {
            ambient: document.getElementById('audio-ambient'),
            music: document.getElementById('audio-music'),
            dialog: document.getElementById('audio-dialog')
        };
        const audioLayers = window.audioLayers;

        const enableBtn = document.getElementById('enable-audio-global');
        // Legacy reference removed: audioEl (web-music)
        const islandEl = document.querySelector('.floating-island');
        const creditsBtn = document.getElementById('credits-btn');
        const creditsOverlay = document.getElementById('credits-overlay');
        const creditsClose = document.getElementById('credits-close');

        // Splat Viewer components
        const splatContainer = document.getElementById('splat-container');
        const splatIframe = document.getElementById('splat-iframe');
        let splatOverlay = null;
        let splatCamera = null;

        let isDragging = false;
        let previousMouseX = 0;
        let dragMoved = false;

        // Click detection
        let mouseDownTime = 0;
        let mouseDownPos = { x: 0, y: 0 };

        function initIslandInteractions() {
            // Helper to capture PlayCanvas camera once the iframe is ready
            const attachSplatCamera = () => {
                if (!splatIframe) return;
                try {
                    const iframeWin = splatIframe.contentWindow;
                    if (!iframeWin || !iframeWin.document) return;
                    const appEl = iframeWin.document.querySelector('pc-app');
                    if (appEl && appEl.app) {
                        const cam = appEl.app.root.findByName('camera');
                        if (cam) {
                            splatCamera = cam;
                            return; // success, stop polling
                        }
                    }
                } catch (err) {
                    // Ignore CORS / timing issues; will retry
                }
                // Retry a few times until it appears
                setTimeout(attachSplatCamera, 150);
            };

            // Mouse Controls for Splat
            const getClientX = (ev) => (ev.touches && ev.touches[0] ? ev.touches[0].clientX : ev.clientX);

            const handleMouseDown = (e) => {
                mouseDownTime = Date.now();
                mouseDownPos = { x: getClientX(e), y: e.clientY };
                isDragging = true;
                previousMouseX = getClientX(e);
                dragMoved = false;
            };

            if (islandEl) {
                islandEl.addEventListener('mousedown', handleMouseDown);
                islandEl.addEventListener('touchstart', handleMouseDown, { passive: true });
            }

            splatOverlay = document.getElementById('splat-overlay');
            if (splatOverlay) {
                splatOverlay.addEventListener('mousedown', handleMouseDown);
                splatOverlay.addEventListener('touchstart', handleMouseDown, { passive: true });
            } else {
                document.addEventListener('mousedown', (e) => {
                    if (e.target.id === 'splat-overlay') {
                        handleMouseDown(e);
                    }
                });
            }

            const handleMove = (e) => {
                if (isDragging) {
                    const clientX = getClientX(e);
                    const deltaX = clientX - previousMouseX;
                    if (Math.abs(deltaX) > 1) dragMoved = true;

                    // Feed spark field yaw so squares/dots rotate with drag
                    if (window.dgSetSparkYaw) {
                        window.dgSetSparkYaw(deltaX * 0.003);
                    }

                    if (splatIframe) {
                        // Rotate Splat Camera
                        try {
                            const iframeWin = splatIframe.contentWindow;
                            if (iframeWin && iframeWin.document && splatCamera) {
                                // Get current position and rotation
                                const pos = splatCamera.getPosition();
                                const currentRot = splatCamera.getEulerAngles();
                                const radius = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
                                let theta = Math.atan2(pos.x, pos.z);

                                theta -= deltaX * 0.0025; // rotate around Y (50% slower)

                                const newX = radius * Math.sin(theta);
                                const newZ = radius * Math.cos(theta);

                                splatCamera.setPosition(newX, pos.y, newZ);
                                // Maintain the pitch (x rotation) while rotating to look at center
                                const dx = 0 - newX;
                                const dz = 0 - newZ;
                                const yaw = Math.atan2(dx, dz) * (180 / Math.PI);
                                splatCamera.setEulerAngles(currentRot.x, yaw, 0);
                            }
                        } catch (err) {
                            // Ignore cross-origin errors if any
                        }
                    }

                    previousMouseX = clientX;
                }
            };

            window.addEventListener('mousemove', handleMove);
            window.addEventListener('touchmove', handleMove, { passive: true });

            const handleUp = (e) => {
                isDragging = false;
            };

            window.addEventListener('mouseup', handleUp);
            window.addEventListener('touchend', handleUp, { passive: true });

            // Setup Iframe Click Listener
            if (splatIframe) {
                splatIframe.onload = () => {
                    try {
                        attachSplatCamera();
                    } catch (e) {
                        console.warn('Cannot access iframe content (likely CORS issue if not local):', e);
                    }
                };
                attachSplatCamera();
            }
        }

        initIslandInteractions();

        let audioAnalyzer = null;
        let dataArray = null;
        let animationFrameId = null;

        function initWaveform() {
            if (audioAnalyzer) return; // already initialized

            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const audioCtx = new AudioContext();
                audioAnalyzer = audioCtx.createAnalyser();
                audioAnalyzer.connect(audioCtx.destination); // Master output

                audioAnalyzer.fftSize = 64;
                const bufferLength = audioAnalyzer.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                // Connect ALL audio layers to the analyzer
                Object.values(audioLayers).forEach(layer => {
                    if (layer) {
                        try {
                            const source = audioCtx.createMediaElementSource(layer);
                            source.connect(audioAnalyzer);
                        } catch (e) {
                            // reduce noise if already connected 
                        }
                    }
                });

                const waveformBars = document.querySelectorAll('.waveform-bar');
                const waveformContainer = document.getElementById('waveform');
                if (waveformContainer) waveformContainer.classList.add('is-visible');

                function draw() {
                    animationFrameId = requestAnimationFrame(draw);
                    audioAnalyzer.getByteFrequencyData(dataArray);

                    waveformBars.forEach((bar, index) => {
                        const value = dataArray[index] || 0;
                        const percent = value / 255;
                        const height = Math.max(2, percent * 34);
                        bar.style.height = `${height}px`;
                    });
                }
                draw();
                return audioCtx;
            } catch (err) {
                console.warn('Waveform init failed:', err);
                return null;
            }
        }



        // Preload background music and SFX to avoid playback delay on first click
        const PRELOAD_BG_SRC = '/assets/web_musica.ogg';
        const PRELOAD_SFX_SRC = '/assets/exito.mp3';

        // Prepare SFX element and preload it
        const sfxEl = new Audio(PRELOAD_SFX_SRC);
        sfxEl.preload = 'auto';
        sfxEl.crossOrigin = 'anonymous';
        // Lower SFX volume to be less intrusive
        sfxEl.volume = 0.1;
        // Trigger load to warm cache (won't autoplay)
        try { sfxEl.load(); } catch (e) { /* ignore load errors */ }

        // Preload settings for layers
        if (audioLayers.music) {
            audioLayers.music.src = PRELOAD_BG_SRC;
            audioLayers.music.volume = 0.4;
        }
        if (audioLayers.ambient) {
            audioLayers.ambient.volume = 0.4;
        }
        if (audioLayers.dialog) {
            audioLayers.dialog.volume = 0.8;
        }

        async function enableGlobalAudio(onlyContext = false) {
            // Initialize waveform (which creates context)
            const ctx = initWaveform();

            // Try to resume context
            if (ctx && ctx.state === 'suspended') {
                try { await ctx.resume(); } catch (e) { }
            } else {
                // Fallback if initWaveform didn't creating one or we need one generic
                const Ctx = window.AudioContext || window.webkitAudioContext;
                if (Ctx) {
                    const tempCtx = new Ctx();
                    await tempCtx.resume();
                }
            }

            if (onlyContext) return;

            if (enableBtn) {
                enableBtn.textContent = 'Audio habilitado';
                enableBtn.disabled = true;
            }
            // Logic to play default music if nothing else is playing? 
            // Original code played `audioEl`.
            // We assume explicit click starts audio, OR we start music by default?
            // "Play" on enable usually implies starting background music.
            // Let's check if any layer is playing.
            const anyPlaying = Object.values(audioLayers).some(l => !l.paused);
            if (!anyPlaying) {
                // Start music by default if nothing playing
                if (audioLayers.music) {
                    audioLayers.music.src = PRELOAD_BG_SRC;
                    try { await audioLayers.music.play(); } catch (e) { }
                    // Update UI state
                    /* We can't easily update `state` from here as it's in another scope. 
                       But the user interacts via clicks mostly. */
                }
            }
        }
        window.enableGlobalAudio = enableGlobalAudio;

        if (enableBtn) enableBtn.addEventListener('click', enableGlobalAudio);

        // Credits overlay interactions
        function openCredits() {
            if (!creditsOverlay) return;
            creditsOverlay.classList.add('is-visible');
            creditsOverlay.setAttribute('aria-hidden', 'false');
            document.body.classList.add('credits-open');
        }

        function closeCredits() {
            if (!creditsOverlay) return;
            creditsOverlay.classList.remove('is-visible');
            creditsOverlay.setAttribute('aria-hidden', 'true');
            document.body.classList.remove('credits-open');
        }

        if (creditsBtn) creditsBtn.addEventListener('click', openCredits);
        if (creditsClose) creditsClose.addEventListener('click', closeCredits);
        if (creditsOverlay) {
            creditsOverlay.addEventListener('click', (ev) => {
                if (ev.target === creditsOverlay) closeCredits();
            });
        }
        window.addEventListener('keydown', (ev) => {
            if (ev.key === 'Escape') closeCredits();
        });


    </script>

    <script>
        // Handle messages from service worker to update progress UI
        (function () {
            const toast = document.getElementById('pwaToast');
            const bar = toast ? toast.querySelector('.pwa-progress > .bar') : null;
            const pct = document.getElementById('pwaToastPct');
            const filenameEl = document.getElementById('pwaToastFilename');
            const sizeEl = document.getElementById('pwaToastSize');
            const cancelBtn = document.getElementById('pwaCancelBtn');

            function formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
            }

            function getFilename(url) {
                try {
                    const urlObj = new URL(url, window.location.origin);
                    const pathname = decodeURIComponent(urlObj.pathname);
                    const parts = pathname.split('/');
                    return parts[parts.length - 1] || pathname;
                } catch (e) {
                    return url;
                }
            }

            function showPwaToast(message, percent, filename = '', fileSize = 0, cachedBytes = 0) {
                if (!toast) return;
                toast.querySelector('.label').textContent = message;
                if (bar) bar.style.width = (percent || 0) + '%';
                if (pct) pct.textContent = Math.round(percent || 0) + '%';

                if (filenameEl) {
                    filenameEl.textContent = filename ? `📄 ${filename}` : '';
                    filenameEl.style.display = filename ? 'block' : 'none';
                }

                if (sizeEl) {
                    if (fileSize > 0 && cachedBytes > 0) {
                        // Show: "45.2 KB | 735.8 MB downloaded"
                        sizeEl.textContent = `${formatBytes(fileSize)} | ${formatBytes(cachedBytes)} descargados`;
                        sizeEl.style.display = 'block';
                    } else if (cachedBytes > 0) {
                        sizeEl.textContent = `${formatBytes(cachedBytes)} descargados`;
                        sizeEl.style.display = 'block';
                    } else if (fileSize > 0) {
                        sizeEl.textContent = formatBytes(fileSize);
                        sizeEl.style.display = 'block';
                    } else {
                        sizeEl.style.display = 'none';
                    }
                }

                toast.hidden = false;
            }

            function hidePwaToast() {
                if (!toast) return;
                toast.hidden = true;
                if (cancelBtn) cancelBtn.hidden = true;
            }

            function showCancelButton() {
                if (cancelBtn) cancelBtn.hidden = false;
            }

            function hideCancelButton() {
                if (cancelBtn) cancelBtn.hidden = true;
            }

            // Cancel button handler
            if (cancelBtn) {
                cancelBtn.addEventListener('click', async () => {
                    if ('serviceWorker' in navigator) {
                        const reg = await navigator.serviceWorker.ready;
                        if (reg && reg.active) {
                            reg.active.postMessage({ type: 'CANCEL_CACHE' });
                            cancelBtn.disabled = true;
                            cancelBtn.textContent = 'Cancelando...';
                        }
                    }
                });
            }

            // Expose a show function used by the other inline script
            window.showPwaToast = showPwaToast;

            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.addEventListener('message', (event) => {
                    const data = event.data || {};

                    if (data.type === 'CACHE_RESUME') {
                        const { cached, total } = data;
                        const pctVal = total ? Math.round((cached / total) * 100) : 0;
                        showPwaToast(`Reanudando... (${cached}/${total})`, pctVal, '', 0, 0);
                        showCancelButton();
                    } else if (data.type === 'CACHE_PROGRESS') {
                        const { cached, total, url, fileSize, cachedBytes } = data;
                        const pctVal = total ? Math.round((cached / total) * 100) : 0;
                        const filename = url ? getFilename(url) : '';
                        showPwaToast(
                            `Guardando recursos... (${cached}/${total})`,
                            pctVal,
                            filename,
                            fileSize || 0,
                            cachedBytes || 0
                        );
                        showCancelButton();
                    } else if (data.type === 'CACHE_ERROR') {
                        // Show error briefly but don't interrupt the download
                        const filename = data.url ? getFilename(data.url) : '';
                        const errorMsg = data.error || `Status: ${data.status}`;

                        if (data.skipping) {
                            // File is being skipped, show briefly
                            console.warn(`[Cache] Skipping file: ${filename} (${errorMsg})`);
                            // Don't update the toast for skipped files - let progress continue
                        } else {
                            // Critical error
                            showPwaToast('Error: ' + filename, 0, '', 0, 0);
                        }
                        // Don't hide cancel button on error, user might want to cancel
                    } else if (data.type === 'CACHE_CANCELLED') {
                        const { cached, total } = data;
                        showPwaToast(`Cancelado: ${cached}/${total} recursos guardados`, 0, '', 0, 0);
                        hideCancelButton();
                        setTimeout(hidePwaToast, 4000);
                    } else if (data.type === 'CACHE_COMPLETE') {
                        const { cached, total, totalBytes } = data;
                        const sizeInfo = totalBytes ? ` (${formatBytes(totalBytes)})` : '';
                        showPwaToast(`Listo: ${cached}/${total} recursos guardados${sizeInfo}`, 100, '', 0, 0);
                        hideCancelButton();
                        setTimeout(hidePwaToast, 3000);
                    }
                });
            }
        })();
    </script>

    <script>
        (function () {
            const MIN_RADIUS = 18;
            const MAX_RADIUS = 38;
            const RATIO = 0.03;
            const MIN_CORNER = 24;
            const MAX_CORNER = 90;
            const CORNER_RATIO = 0.1;
            const frame = document.querySelector('.video-frame');
            const root = document.documentElement;
            if (!frame || !root) return;

            function updateRadius() {
                const rect = frame.getBoundingClientRect();
                if (!rect.width || !rect.height) return;
                const calculated = Math.round(rect.width * RATIO);
                const value = Math.max(MIN_RADIUS, Math.min(MAX_RADIUS, calculated));
                root.style.setProperty('--video-frame-radius', value + 'px');
                const diag = Math.min(rect.width, rect.height);
                const scaledCorner = Math.round(diag * CORNER_RATIO);
                const cornerLength = Math.max(MIN_CORNER, Math.min(MAX_CORNER, scaledCorner));
                root.style.setProperty('--video-frame-corner-length', cornerLength + 'px');
            }

            updateRadius();
            window.addEventListener('resize', updateRadius);
            if (typeof ResizeObserver !== 'undefined') {
                const observer = new ResizeObserver(updateRadius);
                observer.observe(frame);
            }
        })();
    </script>

    <script>
        // Drag and drop functionality for manifesto item
        (function () {
            const manifestoItem = document.querySelector('.manifiesto-item');
            if (!manifestoItem) return;

            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            // Get initial position from computed style
            const style = window.getComputedStyle(manifestoItem);
            xOffset = parseInt(style.left) || 20;
            yOffset = parseInt(style.top) || 20;

            function dragStart(e) {
                if (e.type === "touchstart") {
                    initialX = e.touches[0].clientX - xOffset;
                    initialY = e.touches[0].clientY - yOffset;
                } else {
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                }

                // Only start drag if clicking on the element itself, not scrollbar
                if (e.target === manifestoItem || manifestoItem.contains(e.target)) {
                    isDragging = true;
                    manifestoItem.classList.add('dragging');
                }
            }

            function dragEnd(e) {
                if (isDragging) {
                    initialX = currentX;
                    initialY = currentY;
                    isDragging = false;
                    manifestoItem.classList.remove('dragging');
                }
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();

                    if (e.type === "touchmove") {
                        currentX = e.touches[0].clientX - initialX;
                        currentY = e.touches[0].clientY - initialY;
                    } else {
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                    }

                    xOffset = currentX;
                    yOffset = currentY;

                    // Keep element within viewport bounds
                    const rect = manifestoItem.getBoundingClientRect();
                    const maxX = window.innerWidth - rect.width;
                    const maxY = window.innerHeight - rect.height;

                    xOffset = Math.max(0, Math.min(xOffset, maxX));
                    yOffset = Math.max(0, Math.min(yOffset, maxY));

                    manifestoItem.style.left = xOffset + 'px';
                    manifestoItem.style.top = yOffset + 'px';
                }
            }

            // Mouse events
            manifestoItem.addEventListener('mousedown', dragStart, false);
            document.addEventListener('mouseup', dragEnd, false);
            document.addEventListener('mousemove', drag, false);

            // Touch events
            manifestoItem.addEventListener('touchstart', dragStart, false);
            document.addEventListener('touchend', dragEnd, false);
            document.addEventListener('touchmove', drag, { passive: false });
        })();
    </script>

    <script>
        // Floating text typewriter animation on scroll
        (function () {
            const floatingTexts = document.querySelectorAll('.floating-text');
            if (!floatingTexts.length) return;

            const typewriterConfig = {
                totalDuration: 1000, // Total duration in ms for all characters (faster entry)
                startDelay: 300, // ms before animation starts when element enters viewport
                glitchChars: '█▓▒░@#$%&*ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
                glitchIterations: 2, // Number of random characters to show before the real one
                glitchSpeed: 15 // ms between glitch characters
            };

            // Store original content and state for each floating-text
            const textStates = new Map();

            function initFloatingText() {
                floatingTexts.forEach(container => {
                    // If already initialized, skip
                    if (textStates.has(container)) return;

                    const paragraphs = container.querySelectorAll('p, div');
                    const originalContent = Array.from(paragraphs).map(p => ({
                        element: p,
                        originalHTML: p.innerHTML,
                        isAnimating: false,
                        timeoutId: null,
                        intervalId: null,
                        height: 0,
                        width: 0,
                        textAlign: '',
                        charPositions: [] // Array of {x, y, width, height} for each character
                    }));
                    textStates.set(container, originalContent);

                    // Calculate positions by rendering text invisibly
                    let hasValidHeight = false;
                    originalContent.forEach(state => {
                        const { element, originalHTML } = state;

                        // Store original text-align
                        state.textAlign = window.getComputedStyle(element).textAlign;

                        // Temporarily show full text to measure
                        element.innerHTML = originalHTML;
                        element.style.visibility = 'hidden';
                        element.style.height = 'auto';
                        element.style.width = 'auto';

                        const rect = element.getBoundingClientRect();
                        state.height = rect.height;
                        state.width = rect.width;

                        if (state.height > 0) hasValidHeight = true;

                        // Get character positions relative to element
                        const plainText = element.textContent;
                        const elementRect = element.getBoundingClientRect();

                        for (let i = 0; i < plainText.length; i++) {
                            try {
                                // Create a range for each character
                                let charIndex = 0;
                                let found = false;

                                const walk = (node) => {
                                    if (found) return;
                                    if (node.nodeType === Node.TEXT_NODE) {
                                        for (let j = 0; j < node.textContent.length; j++) {
                                            if (charIndex === i) {
                                                const range = document.createRange();
                                                range.setStart(node, j);
                                                range.setEnd(node, j + 1);
                                                const rects = range.getClientRects();

                                                if (rects.length > 0) {
                                                    const charRect = rects[0];
                                                    state.charPositions.push({
                                                        x: charRect.left - elementRect.left,
                                                        y: charRect.top - elementRect.top,
                                                        width: charRect.width,
                                                        height: charRect.height
                                                    });
                                                } else {
                                                    state.charPositions.push({
                                                        x: 0,
                                                        y: 0,
                                                        width: 0,
                                                        height: 0
                                                    });
                                                }
                                                found = true;
                                                return;
                                            }
                                            charIndex++;
                                        }
                                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                                        for (let child of node.childNodes) {
                                            walk(child);
                                            if (found) return;
                                        }
                                    }
                                };

                                walk(element);
                            } catch (e) {
                                // Fallback if position calculation fails
                                state.charPositions.push({
                                    x: 0,
                                    y: 0,
                                    width: 0,
                                    height: 0
                                });
                            }
                        }

                        // Clear and set proper dimensions ONLY if we got a valid height
                        // Otherwise leave it alone (fallback to static text)
                        if (state.height > 0) {
                            element.innerHTML = '';
                            element.style.visibility = 'visible';
                            element.style.height = state.height + 'px';
                            element.style.width = 'auto';
                        } else {
                            element.style.visibility = 'visible';
                            element.style.height = 'auto';
                        }
                    });

                    // Set container height
                    const maxHeight = originalContent.reduce((max, state) => Math.max(max, state.height), 0);
                    if (maxHeight > 0) {
                        container.style.minHeight = maxHeight + 'px';
                    }
                });
            }

            function getPlainTextLength(html) {
                const temp = document.createElement('div');
                temp.innerHTML = html;
                return temp.textContent.length;
            }

            function getPartialHTML(html, charCount) {
                const temp = document.createElement('div');
                temp.innerHTML = html;
                let count = 0;

                const walk = (node, maxChars) => {
                    if (count >= maxChars) return '';
                    if (node.nodeType === Node.TEXT_NODE) {
                        const remaining = maxChars - count;
                        const text = node.textContent.substring(0, remaining);
                        count += text.length;
                        return text;
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        const tagName = node.tagName.toLowerCase();
                        let result = `<${tagName}>`;
                        for (let child of node.childNodes) {
                            if (count >= maxChars) break;
                            result += walk(child, maxChars);
                        }
                        result += `</${tagName}>`;
                        return result;
                    }
                    return '';
                };

                let result = '';
                for (let child of temp.childNodes) {
                    if (count >= charCount) break;
                    result += walk(child, charCount);
                }
                return result;
            }

            function getPartialHTMLWithGlitch(html, charCount, glitchChar = null) {
                const temp = document.createElement('div');
                temp.innerHTML = html;
                let count = 0;

                const walk = (node, maxChars) => {
                    if (count >= maxChars) return '';
                    if (node.nodeType === Node.TEXT_NODE) {
                        const remaining = maxChars - count;
                        let text = node.textContent.substring(0, remaining);

                        // If we have a glitch character and we're at the last position, replace it
                        if (glitchChar !== null && count + text.length === maxChars && text.length > 0) {
                            text = text.substring(0, text.length - 1) + glitchChar;
                        }

                        count += text.length;
                        return text;
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        const tagName = node.tagName.toLowerCase();
                        let result = `<${tagName}>`;
                        for (let child of node.childNodes) {
                            if (count >= maxChars) break;
                            result += walk(child, maxChars);
                        }
                        result += `</${tagName}>`;
                        return result;
                    }
                    return '';
                };

                let result = '';
                for (let child of temp.childNodes) {
                    if (count >= charCount) break;
                    result += walk(child, charCount);
                }
                return result;
            }

            function animateTypewriter(container) {
                const states = textStates.get(container);
                if (!states) return;

                states.forEach(state => {
                    if (state.isAnimating) return; // Already animating

                    state.isAnimating = true;
                    const { element, originalHTML, charPositions, textAlign } = state;
                    const plainText = element.textContent || getPlainTextLength(originalHTML);
                    const totalChars = typeof plainText === 'string' ? plainText.length : plainText;

                    // Create a wrapper to maintain centering
                    const wrapper = document.createElement('div');
                    wrapper.style.position = 'relative';
                    wrapper.style.display = 'inline-block';
                    wrapper.style.textAlign = 'left';
                    wrapper.style.minHeight = state.height + 'px';
                    wrapper.style.minWidth = state.width + 'px';

                    element.innerHTML = '';
                    element.style.textAlign = textAlign;
                    element.appendChild(wrapper);

                    const getRandomGlitchChar = () => {
                        return typewriterConfig.glitchChars.charAt(
                            Math.floor(Math.random() * typewriterConfig.glitchChars.length)
                        );
                    };

                    // Get the actual text content to display
                    const temp = document.createElement('div');
                    temp.innerHTML = originalHTML;
                    const textContent = temp.textContent;

                    // Create randomized indices
                    const indices = Array.from({ length: totalChars }, (_, i) => i);
                    // Shuffle the indices
                    for (let i = indices.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [indices[i], indices[j]] = [indices[j], indices[i]];
                    }

                    // Calculate time per character including glitch iterations
                    const timePerChar = typewriterConfig.totalDuration / totalChars;
                    const glitchTime = typewriterConfig.glitchIterations * typewriterConfig.glitchSpeed;

                    state.timeoutId = setTimeout(() => {
                        // Animate all characters simultaneously with staggered starts
                        indices.forEach((charIndex, order) => {
                            const startTime = order * timePerChar;

                            // Glitch phase
                            for (let g = 0; g < typewriterConfig.glitchIterations; g++) {
                                setTimeout(() => {
                                    const glitchChar = getRandomGlitchChar();
                                    const pos = charPositions[charIndex] || { x: 0, y: 0 };

                                    let span = wrapper.querySelector(`[data-char-index="${charIndex}"]`);
                                    if (!span) {
                                        span = document.createElement('span');
                                        span.setAttribute('data-char-index', charIndex);
                                        span.style.position = 'absolute';
                                        span.style.left = pos.x + 'px';
                                        span.style.top = pos.y + 'px';
                                        span.style.whiteSpace = 'pre';
                                        wrapper.appendChild(span);
                                    }
                                    span.textContent = glitchChar;
                                }, startTime + g * typewriterConfig.glitchSpeed);
                            }

                            // Final character reveal
                            setTimeout(() => {
                                const realChar = textContent[charIndex];
                                const pos = charPositions[charIndex] || { x: 0, y: 0 };

                                let span = wrapper.querySelector(`[data-char-index="${charIndex}"]`);
                                if (!span) {
                                    span = document.createElement('span');
                                    span.setAttribute('data-char-index', charIndex);
                                    span.style.position = 'absolute';
                                    span.style.left = pos.x + 'px';
                                    span.style.top = pos.y + 'px';
                                    span.style.whiteSpace = 'pre';
                                    wrapper.appendChild(span);
                                }
                                span.textContent = realChar;
                            }, startTime + glitchTime);
                        });

                        // Animation complete - restore original HTML
                        setTimeout(() => {
                            element.innerHTML = originalHTML;
                            element.style.textAlign = '';
                            state.isAnimating = false;
                        }, typewriterConfig.totalDuration + glitchTime + 100);
                    }, typewriterConfig.startDelay);
                });
            }

            // Setup Intersection Observer
            const observerOptions = {
                root: null,
                rootMargin: '0px',
                threshold: 0.2 // Trigger when 20% of the element is visible
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        animateTypewriter(entry.target);
                        observer.unobserve(entry.target); // Animate only once
                    }
                });
            }, observerOptions);

            function startObserving() {
                initFloatingText();
                floatingTexts.forEach(container => observer.observe(container));
            }

            if (document.body.classList.contains('is-loading')) {
                const bodyObserver = new MutationObserver((mutations) => {
                    if (!document.body.classList.contains('is-loading')) {
                        startObserving();
                        bodyObserver.disconnect();
                    }
                });
                bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] });
            } else {
                startObserving();
            }
        })();
    </script>

    <script>
        (function () {
            const canvas = document.getElementById('manifiesto-canvas');
            if (!canvas) return;

            const content = document.querySelector('.grid-frame-content');
            const ctx = canvas.getContext('2d');
            const SQUARE_SIZE = 25;
            const COLS = 8;
            const ROWS = 13;

            const GRID_WIDTH = COLS * SQUARE_SIZE;
            const GRID_HEIGHT = ROWS * SQUARE_SIZE;

            // Margins for the outer elements
            const PADDING = 80;

            canvas.width = GRID_WIDTH + PADDING * 2;
            canvas.height = GRID_HEIGHT + PADDING * 2;

            const startX = PADDING;
            const startY = PADDING;

            // Increase right padding when columns decrease so text stays inside the grid area
            if (content) {
                const BASE_COLS = 10;
                const BASE_RIGHT_PADDING = 30; // matches initial inline padding-right
                const extraRight = Math.max(0, (BASE_COLS - COLS) * SQUARE_SIZE * 0.6);
                content.style.paddingRight = `${Math.round(BASE_RIGHT_PADDING + extraRight)}px`;
            }

            // 1. Grid of transparent blue squares with faint yellow outlines
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.15)'; // Faint yellow (fainter)
            ctx.fillStyle = 'rgba(0, 100, 255, 0.05)'; // Transparent blue (fainter)
            ctx.lineWidth = 1;

            for (let i = 0; i < COLS; i++) {
                for (let j = 0; j < ROWS; j++) {
                    const x = startX + i * SQUARE_SIZE;
                    const y = startY + j * SQUARE_SIZE;
                    ctx.fillRect(x, y, SQUARE_SIZE, SQUARE_SIZE);
                    ctx.strokeRect(x, y, SQUARE_SIZE, SQUARE_SIZE);
                }
            }

            // 2. 4px outsetted from the grid are yellow lines that form a square without corners
            // (the lines stops 5px before meeting in the corner)
            const OUTSET_1 = 16; // Slightly tighter spacing between grid and outer lines
            const CORNER_GAP = 30;

            const frameX = startX - OUTSET_1;
            const frameY = startY - OUTSET_1;
            const frameW = GRID_WIDTH + OUTSET_1 * 2;
            const frameH = GRID_HEIGHT + OUTSET_1 * 2;

            ctx.strokeStyle = '#FFFF00'; // Yellow
            ctx.lineWidth = 1;
            ctx.shadowBlur = 0;

            ctx.beginPath();
            // Top line
            ctx.moveTo(frameX + CORNER_GAP, frameY);
            ctx.lineTo(frameX + frameW - CORNER_GAP, frameY);

            // Bottom line
            ctx.moveTo(frameX + CORNER_GAP, frameY + frameH);
            ctx.lineTo(frameX + frameW - CORNER_GAP, frameY + frameH);

            // Left line
            ctx.moveTo(frameX, frameY + CORNER_GAP);
            ctx.lineTo(frameX, frameY + frameH - CORNER_GAP);

            // Right line
            ctx.moveTo(frameX + frameW, frameY + CORNER_GAP);
            ctx.lineTo(frameX + frameW, frameY + frameH - CORNER_GAP);

            ctx.stroke();

            // 3. Rounded corners just outside the outer frame with a tighter, aligned gap.
            const OFFSET_2 = 14; // Minimal separation to keep corners hugging the frame
            const cornerX = frameX - OFFSET_2;
            const cornerY = frameY - OFFSET_2;
            const cornerW = frameW + OFFSET_2 * 2;
            const cornerH = frameH + OFFSET_2 * 2;
            const CORNER_LENGTH = 55; // Base corner leg length
            const CORNER_BIAS = Math.round(CORNER_LENGTH * 0.01); // Extra run along the clockwise side
            const CORNER_RADIUS = 38; // Balanced curve for the extended legs

            ctx.strokeStyle = '#FFFF00';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowColor = '#FFFF00';
            ctx.shadowBlur = 10; // Glowing

            ctx.beginPath();

            // Top-Left Corner: base run down, arc, then extend along top (clockwise side)
            ctx.moveTo(cornerX, cornerY + CORNER_LENGTH);
            ctx.arcTo(cornerX, cornerY, cornerX + CORNER_LENGTH, cornerY, CORNER_RADIUS);
            ctx.lineTo(cornerX + CORNER_LENGTH + CORNER_BIAS, cornerY);

            // Top-Right Corner: base run along top, arc, then extend down (clockwise side)
            ctx.moveTo(cornerX + cornerW - CORNER_LENGTH, cornerY);
            ctx.arcTo(cornerX + cornerW, cornerY, cornerX + cornerW, cornerY + CORNER_LENGTH, CORNER_RADIUS);
            ctx.lineTo(cornerX + cornerW, cornerY + CORNER_LENGTH + CORNER_BIAS);

            // Bottom-Right Corner: base run down, arc, then extend left along bottom (clockwise side)
            ctx.moveTo(cornerX + cornerW, cornerY + cornerH - CORNER_LENGTH);
            ctx.arcTo(cornerX + cornerW, cornerY + cornerH, cornerX + cornerW - CORNER_LENGTH, cornerY + cornerH, CORNER_RADIUS);
            ctx.lineTo(cornerX + cornerW - CORNER_LENGTH - CORNER_BIAS, cornerY + cornerH);

            // Bottom-Left Corner: base run along bottom, arc, then extend up (clockwise side)
            ctx.moveTo(cornerX + CORNER_LENGTH, cornerY + cornerH);
            ctx.arcTo(cornerX, cornerY + cornerH, cornerX, cornerY + cornerH - CORNER_LENGTH, CORNER_RADIUS);
            ctx.lineTo(cornerX, cornerY + cornerH - CORNER_LENGTH - CORNER_BIAS);

            ctx.stroke();

            // Reset shadow
            ctx.shadowBlur = 0;
        })();
    </script>
    
    <script>
        // Cache busting script - automatically clears caches on new deployments
        const APP_VERSION = '__BUILD_VERSION__';
        
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const storedVersion = localStorage.getItem('app_version');
                    
                    if (storedVersion && storedVersion !== APP_VERSION) {
                        console.log('[App] Version changed, clearing caches...');
                        
                        // Unregister all service workers
                        const registrations = await navigator.serviceWorker.getRegistrations();
                        await Promise.all(registrations.map(reg => reg.unregister()));
                        
                        // Clear all caches
                        const cacheNames = await caches.keys();
                        await Promise.all(cacheNames.map(name => caches.delete(name)));
                        
                        localStorage.clear();
                        sessionStorage.clear();
                        localStorage.setItem('app_version', APP_VERSION);
                        window.location.reload(true);
                        return;
                    }
                    
                    localStorage.setItem('app_version', APP_VERSION);
                    
                    // Register service worker
                    const registration = await navigator.serviceWorker.register(
                        `/service-worker.js?v=${APP_VERSION}`, 
                        { scope: '/' }
                    );
                    
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                console.log('[App] New service worker available');
                            }
                        });
                    });
                    
                    registration.update();
                } catch (err) {
                    console.warn('[App] ServiceWorker error:', err);
                }
            });
        }
    </script>

</body>

</html>